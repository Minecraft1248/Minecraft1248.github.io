[{"id":"14ddd0e5c45607d8ee4621c2813a9657","title":"详解C++ 20标准中的module(模块)","content":" 详解C++ 20标准中的module(模块)\n 0.C++模块简介&amp;前言\n在开始C++模块的介绍之前,首先来看这样一段代码:\n#include&lt;iostream>\nusing namespace std;\nint main() &#123;\n    cout &lt;&lt; \"Hello world\";\n&#125;\n这是一段简单到不能再简单的Hello World,整份代码共计不超过100字,但是关键在于这段代码中使用了cout从而#include&lt;iostream&gt;,导致了预处理器会完整地将&lt;iostream&gt;头文件替换至源代码中,并且还会继续扫描并处理新增加的#include,从而导致编译器真实处理的字符数实际上有上万字,甚至上百万字.\n而这一切,不过是使用了一个cout而引发的结果.\n很难想象,在一个Hello World的编译中就已经是这样了,编译Chromium这种大型项目时需要处理的代码数只会更加恐怖.\n~~不能否认的是,C++的这种编译方式曾在C++程序员的工作中,起到非常摸鱼的作用(指在编译时划水).~~但这种原始的代码替换方式也极大地拖慢了C++的编译速度,并且还使C++代码难以组件化,无法代码隔离等.\n实际上,C标委会早就发现了这些问题,并在2007年逐步开展了研究工作,但是毕竟是标委会,进度非常缓慢.直到2018年C标委会才以微软提供的方案确定了最终草案,并在C++ 20标准中引入了模块.(官网介绍:P1103R3提案)\n通常可以认为,一个程序是由一组翻译单元(Translated units)组合而成,这些翻译单元在没有额外信息下是相互独立的,要将翻译单元联系在一起就需要为这些翻译单元声明外部名称,编译器和链接器就可以使用这些外部名称将独立的翻译单元组合在一起.而模块就可以认为是一个或一组独立的翻译单元和一组外部名称的组合体.模块名(Module name)就是引用这个组合体的符号,模块单元(Module unit)就是组合体的翻译单元,模块接口单元(Module interface unit)就是组合体的一组外部名称.\n一个模块由模块单元组成,模块单元分为模块接口单元和模块实现单元(Module implement unit).一个模块可以有多个模块分区以方便模块代码的组织,模块分区也是模块单元.对于每个模块,必须有一个没有分区的模块接口单元,该模块单元称为主模块接口单元(Primary Module Interface Unit).导入一个模块,实际上就是导入主模块的接口.\n\n 1.C++模块术语\n\n\n\n中文翻译\n英语原文\n\n\n\n\n模块单元\nModule Unit\n\n\n模块名\nModule Name\n\n\n模块接口单元\nModule Interface Unit\n\n\n模块实现单元\nModule Implement Unit\n\n\n主模块接口单元\nPrimary Module Interface Unit\n\n\n私有模块片段\nPrivate Module Fragment\n\n\n全局模块片段\nGlobal Module Fragment\n\n\n模块分区\nModule Partition\n\n\n子模块\nSubmodule\n\n\n可见性\nVisible\n\n\n可达性\nReachable\n\n\n模块链接属性\nModule Linkage\n\n\n\n 2.C++模块语法\n下面这段代码使用module关键字定义了一个名为MyModule的模块单元:\nmodule MyModule;\n注意,该模块无法做为主模块接口单元,要让一个模块成为主模块接口单元,必须在module前加上export关键字:\nexport module MyModule;\n如此声明的MyModule即成为一个主模块接口单元.在定义模块名后,就可以开始使用export关键字导出指定名称了.\n//mymodule.ixx\nexport module MyModule;\n\nexport int v = 1;\n\nexport int f(int i) &#123;\n    return i + 1;\n&#125;\n\nexport class c &#123;\npublic:\n    int DoSomething() &#123;\n        return 0;\n    &#125;\n&#125;;\n\nexport namespace ns &#123;\n    int f2() &#123;\n        return 0;\n    &#125;  \n&#125;\n当然,也可以在export后跟大括号以批量导出名称,则上面的代码可以改写成:\n//mymodule.ixx\nexport module MyModule;\n\nexport &#123;\n    int v = 1;\n\n    int f(int i) &#123;\n        return i + 1;\n    &#125;\n\n    class c &#123;\n    public:\n        int DoSomething() &#123;\n            return 0;\n        &#125;\n    &#125;;\n\n    namespace ns &#123;\n        int f2() &#123;\n            return 0;\n        &#125;  \n    &#125;\n&#125;\n从上述两段代码可以得知,export关键字能导出的有变量(当然也可以是常量),函数,类以及命名空间.其他源文件可以使用import关键字来导入这些名称:\n//importmodule.cpp\nimport MyModule;\nint main() &#123;\n    int i = ns::f2();\n    i = f(i);\n&#125;\n运行完上述代码后,i的值为1,注意没有使用export关键字导出的名称对模块外不可见(也就是无法访问).\n对于已经模块化的头文件(哪些头文件已经模块化暂时取决于编译器),也可以使用import导入:\n//importheaders.ixx\nexport module Print;\nimport &lt;iostream>;\nusing namespace std;\nexport &#123;\n    void print(int i) &#123;\n        cout &lt;&lt; \"Msg : \" &lt;&lt; i &lt;&lt; endl;\n    &#125;\n&#125;\n//main.cpp\nimport MyModule;\nint main() &#123;\n    print(1);\n&#125;\n上述代码运行后会输出&quot;Msg : 1&quot;.\n注意,在模块中使用头文件时应尽量使用import,否则会导致#include在模块内的头文件成为模块的一部分.\n如果要使用的头文件没有模块化并且一定要在模块中使用该头文件的话,一般有两种方式:\n1.import该头文件,并调整设置,让编译器在编译时自动将该头文件模块化(因编译器而异).\n2.在全局模块片段中#include该头文件:\nmodule;\n\n#include&lt;iostream>\n\nexport module MyModule;\nusing namespace std;\nexport &#123;\n    int Print() &#123;\n        cout &lt;&lt; \"Hello\" &lt;&lt; endl;\n    &#125;\n&#125;\n注意上述代码的第一行的module后直接跟了引号,则从module;至export module MyModule;这两行代码之间称之为全局模块片段,其中的所有代码都会被隐式转换至一个称之为&quot;全局模块&quot;的模块中,从而规避#include头文件所导致的模块包含该头文件内容的问题.\n特别需要注意的是,import的头文件/模块内容不会被#define所影响,这时候就可以在全局模块片段中#include该头文件并定义相关宏.\n与全局模块片段相对应的是私有模块片段:\n//privatemodulefragment.ixx\nexport module MyModule;\nexport &#123;\n    //export something...\n&#125;\n\n\nmodule : private;\n从上述代码最后的module : private;开始,至该文件结束,称之为私有模块片段,该片段中的所有符号均仅在该模块中可见.\n注意,标准规定,私有模块片段只能出现在主模块接口单元中,并且具有私有模块片段的模块单元应是其模块的唯一模块单元.\n当然,与传统的header/source相似,模块的声明与实现也可以分开,此时前者称之为模块接口单元,后者称之为模块实现单元:\n//interface.ixx\nexport module MyModule;\nexport &#123;\n    int f(int i);\n&#125;\n//implement.cpp\nmodule MyModule;\nint f(int i) &#123;\n    return i + 1;\n&#125;\n类似的是,模块接口单元中的宏定义对于模块实现单元来说不可见.\n当数个模块具有从属关系时,可以使用子模块:\n//mainmodule.ixx\nexport module MainModule;\nexport import MainModule.Submodule1;\nexport import MainModule.Submodule2;\nexport import MainModule.Submodule3;\n//submodule1.ixx\nexport module MainModule.Submodule1;\nexport f1()&#123;\n    return 0;\n&#125;\n//submodule2.ixx\nexport module MainModule.Submodule2;\nexport f2()&#123;\n    return 1;\n&#125;\n//submodule3.ixx\nexport module MainModule.Submodule3;\nexport f3()&#123;\n    return 2;\n&#125;\n//main.cpp\nimport MainModule;\nint main()&#123;\n    int a = f1();\n    int b = f2();\n    int c = f3();\n&#125;\n需要注意的是,子模块名称中的&quot;.&quot;仅仅是为了表示主模块与子模块之间的从属关系而存在,其本身也属于模块名的一部分,换句话说,形如MainModule.Submodule这样的模块名只是给人看的,在编译器看来,MainModule和MainModule.Submodule是两个毫不相干的模块.\n上述主模块中的语句export import ...;也可适用于将其他模块的符号经由此模块导出的场景.\n如果模块内容很多,在一个文件中可能放不下,这时候可以使用模块分区来对模块代码做逻辑上的分割:\n//mymodule.ixx\nexport module MyModule;\nexport import :part1;\nimport :part2;\n\nexport void f1()&#123;\n    part1();\n    part2();\n&#125;\n//part1.ixx\nmodule;\n#include&lt;iostream>\nexport module MyModule:part1;\nusing namespace std;\nexport void part1()&#123;\n    cout &lt;&lt; \"Part1\" &lt;&lt; endl;\n&#125;\nvoid part1_private()&#123;\n    return;\n&#125;\n//part2.ixx\nmodule;\n#include&lt;iostream>\nexport module MyModule:part2;\nimport :part1;\nusing namespace std;\nexport void part2()&#123;\n    cout &lt;&lt; \"Part2\" &lt;&lt; endl;\n    part1();\n&#125;\n在主模块接口单元中使用export import ...;来导出相应模块分区,如果不需导出则可以去掉export.\n注意,同模块之间的片段相互引用不需要加上主模块的名称,直接使用冒号+模块分区名即可.外部引用想要模块分区才需要使用主模块名+冒号+模块分区名的方式.\n完整的模块使用实例可以参考我的项目:Helium\n 3.C++模块实现现状\n作者目前使用的MSVC编译器对模块的支持已经基本完善,但是还是存在头文件模块化程度不高,以及强行对头文件模块化会有bug之类的问题.甚至有时候会莫名其妙的报内部编译器错误这种让人摸不着头脑的错误.而且Visual Studio的Intellisense和Intellicode对模块的支持不完善,经常~~(总是)~~会有代码无法上色,自动补全等问题.\n不过使用模块所带来的编译速度提升也是相当明显,希望各大编译器厂商能够在C++ 23标准前为我们提供更加完善的C++模块使用体验.\n","slug":"详解C++20标准中的module(模块)","date":"2022-03-12T02:38:02.000Z","categories_index":"Modern C++,C++","tags_index":"C++ 20,Module,Modern C++","author_index":"Minecraft1248"},{"id":"c7d3b952c43c4d1d37f371080088b081","title":"使用std::any在一个变量中存储任意类型的值","content":" 使用std::any在一个变量中存储任意类型的值\n 0.std::any简介\nstd::any是一种在C++ 17标准中被加入的值类型,其变量在可以更改其类型的同时保持类型安全性.同时std::any不需要在初始化时提供其值可能的类型.换句话说,std::any可以存储任意类型的值,并且还限制了对其的类型转换以保证类型安全.\n在获取std::any中所存储的值时,需要用到std::any_cast&lt;variable_type&gt;(any_variable)以获取其中存储的值.并且std::any存储的值类型可以在运行时使用type()成员函数来获取.注意std::any的值是使用衰减类型存储的,即存数组时转换为指针,忽略顶层引用和const.在存储字符串常量时要尤其注意这一点.\n使用std::any时,需要包含&lt;any&gt;头文件,并且要将编译器的语言标准设置为C++ 17及以上.\n 1.std::any使用实例\n下面给出了一个 std::any的使用案例.\n#include&lt;any&gt;\n#include&lt;iostream&gt;\n#include&lt;string&gt;\n\nusing namespace std;\n\nint main() &#123;\n    any a1;    &#x2F;&#x2F;create an empty any variable without initialize\n    any a2 &#x3D; 1.5;    &#x2F;&#x2F;create an any variable with value 1.5 any double type\n\n    a1 &#x3D; true;    &#x2F;&#x2F;a1 has value true and bool type  \n    a2 &#x3D; string(&quot;TEST_STR&quot;);    &#x2F;&#x2F;a2 has value &quot;TEST_STR&quot; and std::string type\n    \n    if(a1.type() &#x3D;&#x3D; typeid(string)) &#123;\n        string s;\n        try &#123;\n            s &#x3D; any_cast&lt;string&gt;(a1);    &#x2F;&#x2F;try to get an string value\n        &#125; catch(bad_any_cast&amp; e) &#123;\n            cerr &lt;&lt; e.what() &lt;&lt; endl;\n        &#125;\n    &#125; \n\n    if(a1.type() &#x3D;&#x3D; typeid(int)) &#123;\n        int i;\n        try &#123;\n            i &#x3D; any_cast&lt;int&gt;(a1);    &#x2F;&#x2F;try to get an int value\n        &#125; catch(bad_any_cast&amp; e) &#123;\n            cerr &lt;&lt; e.what() &lt;&lt; endl;\n        &#125;\n    &#125; \n&#125;\nstd::any_cast&lt;&gt;会在对象为空或所指类型不匹配时抛出std::bad_any_cast.因此,在不检查或不知道对象类型时最好用try-catch块处理此异常.\nstd::any_cast&lt;&gt;会创建一个用于传递值的临时对象用于初始化新对象,若在不需要初始化时(如只需要输出std::any对象的值时)要避免创建临时对象,可以传递一个引用类型作为模板参数:\ncout &lt;&lt; any_cast&lt;int&amp;&gt;(a1) &lt;&lt; endl;\nany_cast&lt;string&amp;&gt;(a1) &#x3D; &quot;TEST_STR_2&quot;;\n若对std::any对象的指针调用std::any_cast&lt;&gt;,在类型匹配时则返回相应类型的指针,若不匹配则返回nullptr.\nauto ptr &#x3D; any_cast&lt;int&gt;(&amp;a1);\nif(ptr) &#123;\n    &#x2F;&#x2F;do something \n&#125;\n要清空一个std::any对象可以使用一下三种方法:\nif(!a.has_value()) &#123;    &#x2F;&#x2F;if a is not empty\n    a.reset();\n    a &#x3D; any&#123;&#125;;\n    a &#x3D; &#123;&#125;;\n&#125;\nstd::any与容器配合可以产生一个能够存储任意对象的容器:\n#include&lt;any&gt;\n#include&lt;iostream&gt;\n#include&lt;list&gt;\n\nusing namespace std;\n\nint main() &#123;\n    list&lt;any&gt; anylist;\n    string str &#x3D; &quot;TEST_STR&quot;;\n\n    anylist.push_back(12);\n    anylist.push_back(true);\n    anylist.push_back(str);\n\n    for(auto a : anylist) &#123;\n        if(a.type() &#x3D;&#x3D; typeid(string)) &#123;\n            &#x2F;&#x2F;do something\n        &#125;\n        if(a.type() &#x3D;&#x3D; typeid(bool)) &#123;\n            &#x2F;&#x2F;do something\n        &#125;\n        if(a.type() &#x3D;&#x3D; typeid(int)) &#123;\n            &#x2F;&#x2F;do something\n        &#125;\n    &#125;\n&#125;\n","slug":"使用stdany在一个变量中存储任意类型的值","date":"2022-02-26T03:52:24.000Z","categories_index":"Modern C++,C++","tags_index":"Modern C++,C++ 17,std::any","author_index":"Minecraft1248"},{"id":"edd55adac64d0984201add6954665563","title":"《算法基础》学习笔记-排序算法测试源代码","content":"#include&lt;iostream&gt;\n#include&lt;cstdlib&gt;\n#include&lt;ctime&gt;\n#include&lt;vector&gt;\n\n#define INF 0x7FFFFFFF\n\nusing namespace std;\n\nint RandomPartition(int* A, int p, int r) &#123;\n\tint a &#x3D; (rand() % (r - p)) + p;\n\tint temp &#x3D; A[r];\n\tA[r] &#x3D; A[a];\n\tA[a] &#x3D; temp;\n\tint q &#x3D; p;\n\tfor (int u &#x3D; p; u &lt; r; u++) &#123;\n\t\tif (A[u] &lt;&#x3D; A[r]) &#123;\n\t\t\tint temp &#x3D; A[u];\n\t\t\tA[u] &#x3D; A[q];\n\t\t\tA[q] &#x3D; temp;\n\t\t\tq++;\n\t\t&#125;\n\t&#125;\n\ttemp &#x3D; A[r];\n\tA[r] &#x3D; A[q];\n\tA[q] &#x3D; temp;\n\treturn q;\n&#125;\n\nvoid RandomQuickSort(int* A, int p, int r) &#123;\n\tif (p &lt; r) &#123;\n\t\tint q &#x3D; RandomPartition(A, p, r);\n\t\tRandomQuickSort(A, p, q - 1);\n\t\tRandomQuickSort(A, q + 1, r);\n\t&#125;\n&#125;\n\nvoid SelectionSort(int* A, int n) &#123;\n\tfor (int i &#x3D; 0; i &lt; n; i++) &#123;\n\t\tint min &#x3D; A[i], minindex &#x3D; i;\n\t\tfor (int j &#x3D; i + 1; j &lt; n; j++) &#123;\n\t\t\tif (A[j] &lt; min) &#123;\n\t\t\t\tmin &#x3D; A[j];\n\t\t\t\tminindex &#x3D; j;\n\t\t\t&#125;\n\t\t&#125;\n\t\tint temp &#x3D; A[i];\n\t\tA[i] &#x3D; A[minindex];\n\t\tA[minindex] &#x3D; temp;\n\t&#125;\n&#125;\n\nvoid InsertionSort(int* A, int n) &#123;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tint key &#x3D; A[i], j &#x3D; i - 1;\n\t\twhile (j &gt;&#x3D; 0 &amp;&amp; A[j] &gt; key) &#123;\n\t\t\tA[j + 1] &#x3D; A[j];\n\t\t\tj--;\n\t\t&#125;\n\t\tA[j + 1] &#x3D; key;\n\t&#125;\n&#125;\n\nvoid Merge(int* A, int p, int q, int r) &#123;\n\tint n1 &#x3D; q - p + 1, n2 &#x3D; r - q, i &#x3D; 0, j &#x3D; 0;\n\tint* B &#x3D; new int[n1 + 1];\n\tint* C &#x3D; new int[n2 + 1];\n\tB[n1] &#x3D; INF;\n\tC[n2] &#x3D; INF;\n\tfor (int i &#x3D; 0; i &lt; n1; i++) B[i] &#x3D; A[p + i];\n\tfor (int i &#x3D; 0; i &lt; n2; i++) C[i] &#x3D; A[q + i + 1];\n\tfor (int k &#x3D; p; k &lt;&#x3D; r; k++) &#123;\n\t\tif (B[i] &lt;&#x3D; C[j]) &#123;\n\t\t\tA[k] &#x3D; B[i];\n\t\t\ti++;\n\t\t&#125;\n\t\telse &#123;\n\t\t\tA[k] &#x3D; C[j];\n\t\t\tj++;\n\t\t&#125;\n\t&#125;\n\tdelete[] B;\n\tdelete[] C;\n&#125;\n\nvoid MergeSort(int* A, int p, int r) &#123;\n\tif (p &lt; r) &#123;\n\t\tint q &#x3D; (p + r) &#x2F; 2;\n\t\tMergeSort(A, p, q);\n\t\tMergeSort(A, q + 1, r);\n\t\tMerge(A, p, q, r);\n\t&#125;\n&#125;\n\nint Partition(int* A, int p, int r) &#123;\n\tint q &#x3D; p;\n\tfor (int u &#x3D; p; u &lt; r; u++) &#123;\n\t\tif (A[u] &lt;&#x3D; A[r]) &#123;\n\t\t\tint temp &#x3D; A[u];\n\t\t\tA[u] &#x3D; A[q];\n\t\t\tA[q] &#x3D; temp;\n\t\t\tq++;\n\t\t&#125;\n\t&#125;\n\tint temp &#x3D; A[r];\n\tA[r] &#x3D; A[q];\n\tA[q] &#x3D; temp;\n\treturn q;\n&#125;\n\nvoid QuickSort(int* A, int p, int r) &#123;\n\tif (p &lt; r) &#123;\n\t\tint q &#x3D; Partition(A, p, r);\n\t\tQuickSort(A, p, q - 1);\n\t\tQuickSort(A, q + 1, r);\n\t&#125;\n&#125;\n\nint main(int argc, char** argv) &#123;\n\tint n &#x3D; 0, lt &#x3D; 0;\n\tclock_t start, end;\n\tdouble temptime &#x3D; 0.0, sum &#x3D; 0.0;\n\tdouble sorttime[5] &#x3D; &#123; 0.0 &#125;;\n\tvector&lt;double&gt; tempsorttime;\n\n\tcout &lt;&lt; &quot;Enter the Input data scale : &quot;;\n\tcin &gt;&gt; n;\n\tcout &lt;&lt; &quot;Enter the Loop time : &quot;;\n\tcin &gt;&gt; lt;\n\n\tint* A &#x3D; new int[n];\n\n\ttempsorttime.clear();\n\tfor (int i &#x3D; 0; i &lt; lt; i++) &#123;\n\t\tsrand((int)time(NULL));\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\tA[i] &#x3D; rand();\n\n\t\tstart &#x3D; clock();\n\t\tInsertionSort(A, n);\n\t\tend &#x3D; clock();\n\t\ttemptime &#x3D; (double)(end - start);\n\t\ttempsorttime.push_back(temptime);\n\t\tcout &lt;&lt; &quot;Insertion Sort time : &quot; &lt;&lt; temptime &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\t&#125;\n\tsum &#x3D; 0.0;\n\tfor (auto i : tempsorttime) &#123;\n\t\tsum +&#x3D; i;\n\t&#125;\n\tsorttime[0] &#x3D; (double)sum &#x2F; lt;\n\n\ttempsorttime.clear();\n\tfor (int i &#x3D; 0; i &lt; lt; i++) &#123;\n\t\tsrand((int)time(NULL));\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\tA[i] &#x3D; rand();\n\n\t\tstart &#x3D; clock();\n\t\tSelectionSort(A, n);\n\t\tend &#x3D; clock();\n\t\ttemptime &#x3D; (double)(end - start);\n\t\ttempsorttime.push_back(temptime);\n\t\tcout &lt;&lt; &quot;Selection Sort time : &quot; &lt;&lt; temptime &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\t&#125;\n\tsum &#x3D; 0.0;\n\tfor (auto i : tempsorttime) &#123;\n\t\tsum +&#x3D; i;\n\t&#125;\n\tsorttime[1] &#x3D; (double)sum &#x2F; lt;\n\n\ttempsorttime.clear();\n\tfor (int i &#x3D; 0; i &lt; lt; i++) &#123;\n\t\tsrand((int)time(NULL));\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\tA[i] &#x3D; rand();\n\n\t\tstart &#x3D; clock();\n\t\tMergeSort(A, 0, n - 1);\n\t\tend &#x3D; clock();\n\t\ttemptime &#x3D; (double)(end - start);\n\t\ttempsorttime.push_back(temptime);\n\t\tcout &lt;&lt; &quot;Merge Sort time : &quot; &lt;&lt; temptime &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\t&#125;\n\tsum &#x3D; 0.0;\n\tfor (auto i : tempsorttime) &#123;\n\t\tsum +&#x3D; i;\n\t&#125;\n\tsorttime[2] &#x3D; (double)sum &#x2F; lt;\n\n\ttempsorttime.clear();\n\tfor (int i &#x3D; 0; i &lt; lt; i++) &#123;\n\t\tsrand((int)time(NULL));\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\tA[i] &#x3D; rand();\n\n\t\tstart &#x3D; clock();\n\t\tQuickSort(A, 0, n - 1);\n\t\tend &#x3D; clock();\n\t\ttemptime &#x3D; (double)(end - start);\n\t\ttempsorttime.push_back(temptime);\n\t\tcout &lt;&lt; &quot;Quick Sort time : &quot; &lt;&lt; temptime &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\t&#125;\n\tsum &#x3D; 0.0;\n\tfor (auto i : tempsorttime) &#123;\n\t\tsum +&#x3D; i;\n\t&#125;\n\tsorttime[3] &#x3D; (double)sum &#x2F; lt;\n\n\ttempsorttime.clear();\n\tfor (int i &#x3D; 0; i &lt; lt; i++) &#123;\n\t\tsrand((int)time(NULL));\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\tA[i] &#x3D; rand();\n\n\t\tstart &#x3D; clock();\n\t\tRandomQuickSort(A, 0, n - 1);\n\t\tend &#x3D; clock();\n\t\ttemptime &#x3D; (double)(end - start);\n\t\ttempsorttime.push_back(temptime);\n\t\tcout &lt;&lt; &quot;Randomized Quick Sort time : &quot; &lt;&lt; temptime &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\t&#125;\n\tsum &#x3D; 0.0;\n\tfor (auto i : tempsorttime) &#123;\n\t\tsum +&#x3D; i;\n\t&#125;\n\tsorttime[4] &#x3D; (double)sum &#x2F; lt;\n\n\tcout &lt;&lt; endl &lt;&lt; &quot;Final time:&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Insertion Sort : &quot; &lt;&lt; sorttime[0] &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Selection Sort : &quot; &lt;&lt; sorttime[1] &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Merge Sort : &quot; &lt;&lt; sorttime[2] &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Quick Sort : &quot; &lt;&lt; sorttime[3] &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Randomized Quick Sort : &quot; &lt;&lt; sorttime[4] &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\n\tdelete[] A;\n\tA &#x3D; NULL;\n\tsystem(&quot;pause&quot;);\n\treturn 0;\n&#125;\n","slug":"Algorithm-Unlocked-Sort-Test-Source-Code","date":"2021-10-30T16:13:46.000Z","categories_index":"算法基础,Algorithms Unlocked,学习笔记","tags_index":"Notes,Sort,排序算法","author_index":"Minecraft1248"},{"id":"2e4dd07c9efba521a4f50b17ccdbb5c4","title":"《算法基础》学习笔记-线性搜索算法","content":" 《算法基础》学习笔记\n 一.线性搜索算法\n《算法基础》在讲下列算法之前是在讲变量,循环等基础,而且我确信有点基础的人第一个想出来的线性搜索算法也应该是原书中BetterLinearSearch()这样的,故直接跳过\n 1.BetterLinearSearch()\n C++实现:\n#define NOT_FOUND -1\n\nint BetterLinearSearch(int* A, int n, int x) &#123;\n    for(int i &#x3D; 0; i &lt; n; i ++)\n        if(A[i] &#x3D;&#x3D; x) &#123;\n            return i;\n        &#125;\n    return NOT_FOUND;\n&#125;\n 算法分析:\n​    从数组A的开头搜索到末尾,一旦搜索到x就直接返回,若没有搜索到x即返回NOT_FOUND.\n 运行时间:\n​    最好情况下为θ(1),最坏情况下为θ(n),此处不再证明.\n 2.SentinelLinearSearch()\n​    我们注意到BetterLinearSearch()中的循环每迭代一次就要执行2次比较:一次是检查是否找到x的,另一次是检查数组访问越界的,我们可以就此入手,将A[n-1]替换为x,故程序总能在A中找到x并结束,并且只需要在i=n-1时额外检查是否真正找到了x.\n C++实现:\n#define NOT_FOUND -1\n\nint SentinelLinearSearch(int* A, int n, int x)&#123;\n    int last &#x3D; A[n - 1], i &#x3D; 0;\n    A[n - 1] &#x3D; x;\n    while(A[i] !&#x3D; x) i ++; \n    A[n - 1] &#x3D; last;\n    if(i &#x3D;&#x3D; n - 1 &amp;&amp; last !&#x3D; x) return NOT_FOUND;\n    else return i;\n&#125;\n 算法分析:\n​    SentinelLinearSearch()先保存A[n-1]的值并将x赋值给A[n-1],确保了执行到i=n-1时总有A[i]==x恒成立,则循环必定结束,此时只需要还原A[n-1]的值,并进行检查即可.其中,x被称为信号量.\n 运行时间\n​    最好情况下为θ(1),最坏情况下为θ(n),此处不再证明.\n","slug":"Algorithm-Unlocked-Note-2021-10-29-linear-search","date":"2021-10-29T10:28:24.000Z","categories_index":"算法基础,Algorithms Unlocked,学习笔记","tags_index":"Notes,Sort,线性搜索算法","author_index":"Minecraft1248"},{"id":"4b62e9d40a3e4e08517eb0d7ae0aa728","title":"《算法基础》学习笔记-比较排序算法","content":" 《算法基础》学习笔记\n 二.比较排序算法\n 0.定义:\n​\t只使用对排序关键字的比较操作来进行排序的算法,称为比较排序算法.\n​\t此处仅讨论对将数组排序成递增顺序的排序算法,即数组中每个元素均大于等于其前驱.要进行递增的比较排序,需要定义排序关键字的&quot;小于&quot;等判断的意义.\n​\t在排序时,参与排序比较的数据称之为排序关键字,与排序关键字相关联的数据称为卫星数据.\n 1.选择排序\n 选择排序的C++实现:\nvoid SelectionSort(int* A, int n)&#123;\t&#x2F;&#x2F;A:待排序数组指针, n:数组内元素个数\n\tfor(int i &#x3D; 0; i &lt; n; i ++)&#123;\n\t\tint min &#x3D; A[i], minindex &#x3D; i;\n\t\tfor(int j &#x3D; i + 1; j &lt; n; j ++)&#123;\t&#x2F;&#x2F;找出A[i+1...n-1]中最小值下标\n\t\t\tif(A[j] &lt; min)&#123;\n\t\t\t\tmin&#x3D; A[j];\n\t\t\t\tminindex &#x3D; j;\n\t\t\t&#125;\n\t\t&#125;\n\t\tint temp &#x3D; A[i];\t&#x2F;&#x2F;交换最小值与A[i]的值\n\t\tA[i] &#x3D; A[minindex];\n\t\tA[minindex] &#x3D; temp;\n\t&#125;\n&#125;\n 算法分析:\n​\t假设一开始整个数组A是无序的,故找出A[0…n-1]当中的最小值,将其调换至数组起始,则此时A[1…n-1],即除A[0]外的整个数组,其所包含的元素均大于等于A[0]的值,故此时A[0]有序,A[1…n-1]无序,故再在A[1…n-1]当中找出最小值并调换至A的有序部分的末端,依此类推.\n 运行时间及循环不等式:\n 选择排序的循环不等式:\n​\t当SelectionSort()中循环开始时,A[0…i]中元素为A的前i个有序排列的最小元素.\n 选择排序的运行时间:\n​\t当i=0时,SelectionSort()的内层循环变量从1自加至n,共执行n-1次,易知内层循环总会执行n-1-i次,又因为i由0自加至n,故内层循环一共被执行n-1次.设其余操作均花费常量时间.故:\nTinner=(n−1)+(n−2)+…+2+1T_{inner}=(n-1)+(n-2)+\\ldots+2+1\nTinner​=(n−1)+(n−2)+…+2+1\n​\t这是一个等差数列求和,故由:\nk+(k−1)+(k−2)+…+2+1=k(k+1)2,其中k∈N+k+(k-1)+(k-2)+\\ldots+2+1=\\frac {k(k+1)}2,其中k\\in N+\nk+(k−1)+(k−2)+…+2+1=2k(k+1)​,其中k∈N+\n​\t有:\nT=(n−1)+(n−2)+…+2+1=(n−1)(n−1+1)2=(n2−n)2T=(n-1)+(n-2)+\\ldots+2+1=\\frac {(n-1)(n-1+1)}2=\\frac {(n^2-n)}2\nT=(n−1)+(n−2)+…+2+1=2(n−1)(n−1+1)​=2(n2−n)​\nT(n)=θ(n2)T(n)=\\theta (n^2)\nT(n)=θ(n2)\n 总结\n​\t在SelectionSort()运行过程中的内循环中if语句会执行n^2次,但仅仅移动了元素n次,若元素移动耗时(比如磁盘)或元素大小太大时,可以考虑使用选择排序.\n 2.插入排序\n 插入排序的C++实现:\nvoid InsertionSort(int* A, int n)&#123;\t&#x2F;&#x2F;输入与相同选择排序x&#39;t\n\tfor(int i &#x3D; 1; i &lt; n; i ++)&#123;\n\t\tint key &#x3D; A[i], j &#x3D; i - 1;\t&#x2F;&#x2F;选择要向左比较的数\n\t\twhile(j &gt;&#x3D; 0 &amp;&amp; A[j] &gt; key)&#123;\n\t\t\tA[j + 1] &#x3D; A[j];\t&#x2F;&#x2F;将比key大的数向右移\n\t\t\tj --;\n\t\t&#125;\n\t\tA[j + 1] &#x3D; key;\t&#x2F;&#x2F;将key插入向右移空出的空位\n\t&#125;\n&#125;\n 算法分析:\n​\t假设整个数组A是无序的,令i由1自加到n,让每个A[i]与子数组A[0…i-1],即A[i]的所有前驱,从A[i-1]比较至A[0],若其前驱大于A[i],则令其向右移一个单位,若其前驱小于A[i]或访问数组即将越界,停止比较,并将A[i]插入右移元素空出的空位.\n 运行时间及循环不变式:\n 插入排序的循环不变式:\n​\t当InsertionSort()中的循环开始迭代时,A[0…i-2]包含其未被排序时子数组A[0…i-1]的全部元素,但此时A[0…i-2]已排好序.\n 插入排序的运行时间:\n​\t1.最坏情况:\n​\t\t当InsertionSort()中的外层循环开始第一次执行时,A[i]应赋值给A[0],即j从i-1自减至0,内层循环执行i次,此时内层循环因j&gt;=0不成立,或数组访问越界而停止.故外层循环共执行n-1次,设其他操作均花费常量时间.则有执行时间:\nT(n)=1+2+…+(n−2)+(n−1)=(n−1)(n−1+1)2=(n2−n)2T(n)=1+2+\\ldots +(n-2)+(n-1)=\\frac {(n-1)(n-1+1)}2=\\frac {(n^2-n)}2\nT(n)=1+2+…+(n−2)+(n−1)=2(n−1)(n−1+1)​=2(n2−n)​\n​\t故最坏情况下:\nT(n)=θ(n2)T(n)=\\theta (n^2)\nT(n)=θ(n2)\n​\t2.最好情况:\n​\t\t此时内层循环会花费常量时间,故有最好情况下:\nT(n)=θ(n)T(n)=\\theta (n)\nT(n)=θ(n)\n​\t综上所述,运行时间为最好情况θ(n),最坏情况θ(n^2).\n 3.归并排序\n 归并排序的C++实现:\n#define INF 0x7FFFFFFF\n\nvoid Merge(int* A, int p, int q, int r)&#123;\t&#x2F;&#x2F;A:待归并数组指针,p:归并区段起始下标,q:归并区段中间点下标,r:归并区段末尾下标\n\tint n1 &#x3D; q - p + 1, n2 &#x3D; r - q, i &#x3D; 0, j &#x3D; 0;\n\tint* B &#x3D; new int[n1 + 1];\t&#x2F;&#x2F;制作两个堆\n\tint* C &#x3D; new int[n2 + 1];\n\tB[n1] &#x3D; INF;\t&#x2F;&#x2F;信号量\n\tC[n2] &#x3D; INF;\n\tfor(int i &#x3D; 0; i &lt; n1; i ++) B[i] &#x3D; A[p + i];\t&#x2F;&#x2F;拷贝元素\n\tfor(int i &#x3D; 0; i &lt; n2; i ++) C[i] &#x3D; A[q+i+1];\n\tfor(int k &#x3D; p; k &lt;&#x3D; r; k ++)&#123;\n\t\tif(B[i] &lt;&#x3D; C[j]) &#123;\n\t\t\tA[k] &#x3D; B[i];\n\t\t\ti ++;\n\t\t&#125; else&#123;\n\t\t\tA[k] &#x3D; C[j];\n\t\t\tj ++;\t\n\t\t&#125;\n\t&#125;\n\tdelete[] B;\n\tdelete[] C;\n&#125;\n\nvoid MergeSort(int* A, int p, int r)&#123;\t&#x2F;&#x2F;A:待排序数组指针,p:起始下标,r:结束下标\n\tif(p &lt; r)&#123;\t&#x2F;&#x2F;若p&gt;&#x3D;r时,A已有序,直接返回\n\t\tint q &#x3D; (p + r) &#x2F; 2;\t&#x2F;&#x2F;分解问题\n\t\tMergeSort(A, p, q);\t&#x2F;&#x2F;递归求解子问题\n\t\tMergeSort(A, q + 1, r);\n\t\tMerge(A, p, q, r);\t&#x2F;&#x2F;合并子问题解\n\t&#125;\n&#125;\n\n 算法分析:\n​\t分治法的一般概述:\n​\t1.分解:把一个问题分解为多个子问题,这些子问题是更小实例上的原问题.\n​\t2.解决:递归地求解子问题,当子问题足够小时,按照基础情况来求解.\n​\t3.合并:把子问题的解合并为原问题的解.\n​\t分治法在归并排序中的应用:\n​\t1.分解:通过找到位于p和r中间位置的下标q来对问题进行分解,q等于p加r的和除以2,并向下取整.\n​\t2.解决:对分解步骤的两个子问题的数组进行递归排序,即对A[p…q]和A[q+1…r]分别进行递归排序.\n​\t3.合并:将A[p…q]和A[q+1…r]这两个已经排好序的数组进行合并,使得A[p…r]排好序.\n​\t当子问题的数组中的元素个数小于等于1时(即p &gt;= r时),基础情况发生,因为一个只包含1个元素或空的数组总是有序的.\n​\t4.合并方式:\n​\t将A[p…q]和A[q+1…r]中的元素分别制作为两个堆,并将&quot;无限&quot;(此处的无限可取排序关键字永远不会等于的值)插入堆底,易知两个堆堆顶元素均为其所在堆中最小元素,故A[p],A[p+1]的值应为B[0],C[0],且A[p] &lt;= A[p+1],依此类推.\n​\t用此方法归并时,易知数组A[p…r]中的每个元素均被移动了2次,一次是制作堆时,另一次是将其由堆归入A时,故当A[p…r]包含n个元素时,归并这一过程移动了2n次元素且至多比较n次,即线性时间内的归并.\n​\t用此方法进行的归并不是原址的,虽然我们可以实现线性时间内的原址归并,但是实现方式相当复杂.\n​\t为了避免每归并一对元素时均要检查是否数组访问越界,我们在数组B,C最后插入一个大于任意元素的值,与SentinelLinearSearch()相类似.这里使用了#define INF 0x7FFFFFFF来取int类型占4字节时的最大值,以INF作为标记的排序关键字,以便一个带有INF的的关键字是数组中的剩余最小元素时,无需检查哪个数组还有最小的剩余元素.\n​\t因为B,C中元素个数差不会大于1,故当B,C中所有的剩余元素归并完时,B,C的最小剩余元素均为INF,但此时循环因为k &gt; r而退出,因此无需再次比较剩余元素大小.\n 运行时间\n​\t归并排序的运行时间T(n)来自分治法的三个部分耗费时间的累加和:\n​\t1.分解花费常量时间来计算下标q.\n​\t2.解决包括两个数组的递归调用,每个子数组有n/2个元素.定义每个子数组递归调用的花费时间为T(n/2).\n​\t3.通过合并排序好的子数组来合并这两个递归调用的结果需要花费θ(n)时间.\n​\t因与合并所需的θ(n)时间相比,分解所需时间只是一个低阶项,故可以将分解时间并入合并时间,即分解和合并共花费θ(n)时间,解决步骤花费2*T(n/2)时间,故有:\nT(n)=2T(T2)+θ(n)T(n)=2T(\\frac T2)+\\theta (n)\nT(n)=2T(2T​)+θ(n)\n​\t在这个等式中,T(n)被用于描述自己,我们称这样一个等式为递归式,因为归并排序为一个应用了分治法的算法,故我们可以用一个称之为主方法的标准化方法来将T(n)表达为非递归形式.\n​\t主方法:\n​\t对于形为如下的递归式:\nT(n)=aT(nb)+f(n),a∈[1,+∞),b∈(1,+∞),f(n)为渐近正函数T(n)=aT(\\frac nb)+f(n),a\\in [1,+\\infin),b\\in (1,+\\infin),f(n)为渐近正函数\nT(n)=aT(bn​)+f(n),a∈[1,+∞),b∈(1,+∞),f(n)为渐近正函数\n​\t其中a,b为参数,且n/b可能不是整数,但是对n/b进行向上或向下取整不影响递归式的渐近性质.\n​\t主方法主要依赖于主定理:\n令a⩾1和b&gt;1是常数,f(n)是一个函数,T(n)是定义在非负整数上的递归式:T(n)=aT(nb)+f(n)令a⩾1和b&gt;1是常数,f(n)是一个函数,T(n)是定义在非负整数上的递归式:\nT(n) = aT(\\frac{n}{b}) + f(n)\n令a⩾1和b&gt;1是常数,f(n)是一个函数,T(n)是定义在非负整数上的递归式:T(n)=aT(bn​)+f(n)\n其中我们将nb解释为⌈nb⌉或⌊nb⌋。那么T(n)有如下渐进界：其中我们将\\frac{n}{b} 解释为 \\lceil\\frac{n}{b}\\rceil或\\lfloor\\frac{n}{b}\\rfloor。那么T(n)有如下渐进界：\n其中我们将bn​解释为⌈bn​⌉或⌊bn​⌋。那么T(n)有如下渐进界：\n1.若对某个常数ε&gt;0有f(n)=O(nlogba−ε),则T(n)=Θ(nlogba)f(n)多项式意义上的小于(渐进小于)nlogban1.若对某个常数\\varepsilon &gt;0有f(n)=O(n^{log_{b}a-\\varepsilon}),则T(n) = \\Theta(n^{log_{b}a})f(n)多项式意义上的小于(渐进小于)n^{log_{b}a}n\n1.若对某个常数ε&gt;0有f(n)=O(nlogb​a−ε),则T(n)=Θ(nlogb​a)f(n)多项式意义上的小于(渐进小于)nlogb​an\n2.若f(n)=Θ(nlogbalgkn),则T(n)=Θ(nlogbalgk+1n)2.若f(n) = \\Theta(n^{log_{b}a}lg^kn),则T(n) = \\Theta(n^{log_{b}a}lg^{k+1}n)\n2.若f(n)=Θ(nlogb​algkn),则T(n)=Θ(nlogb​algk+1n)\n(若对某个常数ε&gt;0有f(n)=Ω(nlogba+ε),且对于某个常数c&lt;1和所有充分大的n有af(nb)⩽c,那T(n)=Θ(f(n)).(f(n)多项式意义上的大于(渐进大于)nlogba)(若对某个常数\\varepsilon &gt; 0有f(n) = \\Omega(n^{log_{b}a+\\varepsilon}),且对于某个常数c&lt;1和所有充分大的n有af(\\frac{n}{b}) \\leqslant c,那T(n)=\\Theta(f(n)).(f(n)多项式意义上的大于(渐进大于)n^{log_{b}a})\n(若对某个常数ε&gt;0有f(n)=Ω(nlogb​a+ε),且对于某个常数c&lt;1和所有充分大的n有af(bn​)⩽c,那T(n)=Θ(f(n)).(f(n)多项式意义上的大于(渐进大于)nlogb​a)\n​\t故可知T(n)=θ(nlgn).该运行时间适合于归并排序的所有情况.\n 4.快速排序\n 快速排序的C++实现:\nint Partition(int* A, int p, int r)&#123;\n\tint q &#x3D; p;\n\tfor(int u &#x3D; p; u &lt; r; u ++)&#123;\n\t\tif(A[u] &lt;&#x3D; A[r])&#123;\n\t\t\tint temp &#x3D; A[u];\n\t\t\tA[u] &#x3D; A[q];\n\t\t\tA[q] &#x3D; temp;\n\t\t\tq ++;\n\t\t&#125;\n\t&#125;\n\tint temp &#x3D; A[r];\n\tA[r] &#x3D; A[q];\n\tA[q] &#x3D; temp;\n\treturn q;\n&#125;\n\nvoid QuickSort(int* A, int p, int r)&#123;\n\tif(p &lt; r)&#123;\n\t\tint q &#x3D; Partition(A, p, r);\n\t\tQuickSort(A, p, q - 1);\n\t\tQuickSort(A, q + 1, r);\n\t&#125;\n&#125;\n 算法分析:\n​\t快速排序也使用了分治法,故有描述如下:\n​\t1.分解:首先选择A[p…r]中的一个元素,称为主元,对数组A中除了主元外的元素进行排序,让小于等于主元的元素排在主元的左侧,让所有大于主元的元素排在主元的右侧,我们称这一过程为划分.注意,划分后主元左侧的所有元素和主元右侧的所有元素均是无序的.\n​\t2.解决:通过递归地对主元左侧的和右侧的元素进行排序来解决子问题,也就是说,若分解步骤将主元移动到位置q,随后就会递归地对从p到q-1的元素进行排序,同时对q+1到r的元素进行排序.\n​\t3.合并:经过前两个步骤后,数组A已经有序,因此不需合并.\n​\t与归并排序相同,当待排序的子数组元素数量小于等于1时,基础情况发生.\n​\t快速排序的关键是划分数组,与归并排序相同的是,我们同样能在θ(n)时间内划分n个元素,选择数组A中的末尾元素,即A[r],作为主元,任意时刻,A[p…r-1]中的元素将会被划分到下列4个组的一个组中,且这四个组均位于A[p…r]中.按空间顺序从前向后排列依次是:\n​\t组L(左侧组):此组中所包含的元素均小于等于主元,即A[p…q-1].\n​\t组R(右侧组):此组中所包含的元素均大于主元,即A[q…u-1].\n​\t组U(未知组):此组中所包含的元素还未与主元比较,即A[u…r-1].\n​\t组P(主元):即主元,或A[r].\n​\t快速排序自左向右检查组U中的元素,将它们与主元进行比较,并将它们移动到组L或组R中,一旦检查到主元位置处,就停止所有操作.与主元进行比较的元素始终是组U中最左侧的元素.\n​\t(1).若组U中的元素大于主元,就将组R和组U之间的界限向右移1个单位.故此时比较的组U中元素成为组R中最后的元素.\n​\t(2).若组U中的元素小于等于主元,则将此元素与组R最前的元素进行调换,并将组L和组R,组R和组U之间的界限均向右移1个单位.\n​\t(3).一旦检查到主元位置,就将主元与组R最前的元素调换.\n​\t快速排序将数组中每个除主元外的元素与主元比较1次,当元素小于等于主元时会产生一次调换.因此,划分n个元素时,快速排序至多进行n-1次比较(主元无需比较),至多进行n次调换.并且划分这一过程是完全原址的.\n 运行时间及循环不变式\n 快速排序的循环不变式:\n​\t划分过程中四个组的划分方式即为此算法的循环不变式,这里不再赘述.\n 快速排序的运行时间:\n​\t设每次比较和调换操作均花费常量时间,故对包含n个元素的子数组进行划分操作需要的总时间是θ(n).\n​\t在最坏情况下,即A为逆序的,划分得到的大小是相当不均衡的,若除了主元之外的所有元素均小于主元,则划分的结果是A[p…r-1],即除去主元的剩余部分,且QuickSort()最终会返回在q中的索引r值.这种情况下,A[q+1…r]是空的,且A[p…q-1]仅仅比A[p…r]少一个元素.对空的子数组进行递归调用需要θ(1)时间,对于划分,我们可以将θ(1)并入θ(n)时间内,但是如果A[p…r]有n个元素,那么A[p…q-1]有n-1个元素,故对A[p…q-1]进行递归调用需要花费T(n-1)时间,故有:\nT(n)=T(n−1)+θ(n)⇒T(n)=θ(n2)T(n)=T(n-1)+\\theta (n)\\Rightarrow T(n)=\\theta (n^2)\nT(n)=T(n−1)+θ(n)⇒T(n)=θ(n2)\n​\t另一方面,若每次都能得到一个均匀的划分,则每个子数组最多有n/2个元素,故有:\nT(n)=2T(n2)+θn⇒T(n)=θ(nlgn)T(n)=2T(\\frac n2)+\\theta n\\Rightarrow T(n)=\\theta (nlgn)\nT(n)=2T(2n​)+θn⇒T(n)=θ(nlgn)\n​\t一般而言,当输入数组为完全随机产生时,T(n)≈θ(nlgn).\n​\t我们也可以在A[p…r]中随机选取3个元素,并将这3个元素中值介于其他两个元素的元素设为主元,即与A[r]调换,这称为随机快速排序,上文所述称为确定的快速排序.\n 5.多种比较排序算法的用时比较\n 理论用时:\n\n\n\n比较排序算法\n最坏情况下运行时间\n最好情况下运行时间\n最坏情况下调换次数\n是否原址\n\n\n\n\n选择排序\nθ(n^2)\nθ(n^2)\nθ()\n是\n\n\n插入排序\nθ(n^2)\nθ(n)\nθ(n^2)\n是\n\n\n归并排序\nθ(nlgn)\nθ(nlgn)\nθ(nlgn)\n否\n\n\n快速排序\nθ(n^2)\nθ(nlgn)\nθ(n^2)\n是\n\n\n\n 实际用时:\n​\t实现语言:C++14\n​\t编译器:MSVC v143 优化/O2\n​\t操作系统:Windows 11 家庭中文版 22468.1000\n​\t处理器:Intel Core i9-8950HK 2.90GHz\n​\t内存:32GB 2667MHz\n​\t数据规模:由50至500000个随机产生的int类型元素,范围由0至2147483647\n​\t测试方式:每种算法独立运行20次取花费时间平均值\n\n\n\n算法\nn=50\nn=100\nn=500\nn=1000\nn=5000\nn=10000\nn=50000\nn=100000\nn=500000\n\n\n\n\n插入排序\n&lt;0.01ms\n&lt;0.01ms\n&lt;0.01ms\n0.2ms\n2.65ms\n10.55ms\n249.25ms\n1151.05ms\n39167.6ms\n\n\n选择排序\n&lt;0.01ms\n&lt;0.01ms\n0.05ms\n0.3ms\n10.1ms\n39.2ms\n907.6ms\n3805.5ms\n126624ms\n\n\n归并排序\n0.05ms\n0.05ms\n0.1ms\n0.2ms\n2.1ms\n4.8ms\n13.6ms\n30.6ms\n115.8ms\n\n\n确定的快速排序\n&lt;0.01ms\n&lt;0.01ms\n&lt;0.01ms\n0.15ms\n0.15ms\n0.25ms\n3.55ms\n7.5ms\n29.6ms\n\n\n随机快速排序\n&lt;0.01ms\n&lt;0.01ms\n0.1ms\n0.1ms\n0.45ms\n0.75ms\n4.4ms\n8.95ms\n39.6ms\n\n\n\n这个测试结果跟《算法基础》测的的数据有些偏差,譬如选择排序耗时几乎是相同情况下插入排序的3-4倍,甚至更多,随机快速排序比相同情况下确定的快速排序要慢等情况,碍于篇幅,我会在另一篇单独的文章中放出实现源代码.\n另:Aurora主题似乎还不支持使用MathJax渲染数学公式,也只能这样了w.\n","slug":"Algorithm-Unlocked-Note-2021-10-29-sort","date":"2021-10-29T10:27:54.000Z","categories_index":"算法基础,Algorithms Unlocked,学习笔记","tags_index":"Notes,Sort,排序算法","author_index":"Minecraft1248"}]