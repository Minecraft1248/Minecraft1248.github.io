[{"id":"edd55adac64d0984201add6954665563","title":"《算法基础》学习笔记-排序算法测试源代码","content":"#include&lt;iostream&gt;\n#include&lt;cstdlib&gt;\n#include&lt;ctime&gt;\n#include&lt;vector&gt;\n\n#define INF 0x7FFFFFFF\n\nusing namespace std;\n\nint RandomPartition(int* A, int p, int r) &#123;\n\tint a &#x3D; (rand() % (r - p)) + p;\n\tint temp &#x3D; A[r];\n\tA[r] &#x3D; A[a];\n\tA[a] &#x3D; temp;\n\tint q &#x3D; p;\n\tfor (int u &#x3D; p; u &lt; r; u++) &#123;\n\t\tif (A[u] &lt;&#x3D; A[r]) &#123;\n\t\t\tint temp &#x3D; A[u];\n\t\t\tA[u] &#x3D; A[q];\n\t\t\tA[q] &#x3D; temp;\n\t\t\tq++;\n\t\t&#125;\n\t&#125;\n\ttemp &#x3D; A[r];\n\tA[r] &#x3D; A[q];\n\tA[q] &#x3D; temp;\n\treturn q;\n&#125;\n\nvoid RandomQuickSort(int* A, int p, int r) &#123;\n\tif (p &lt; r) &#123;\n\t\tint q &#x3D; RandomPartition(A, p, r);\n\t\tRandomQuickSort(A, p, q - 1);\n\t\tRandomQuickSort(A, q + 1, r);\n\t&#125;\n&#125;\n\nvoid SelectionSort(int* A, int n) &#123;\n\tfor (int i &#x3D; 0; i &lt; n; i++) &#123;\n\t\tint min &#x3D; A[i], minindex &#x3D; i;\n\t\tfor (int j &#x3D; i + 1; j &lt; n; j++) &#123;\n\t\t\tif (A[j] &lt; min) &#123;\n\t\t\t\tmin &#x3D; A[j];\n\t\t\t\tminindex &#x3D; j;\n\t\t\t&#125;\n\t\t&#125;\n\t\tint temp &#x3D; A[i];\n\t\tA[i] &#x3D; A[minindex];\n\t\tA[minindex] &#x3D; temp;\n\t&#125;\n&#125;\n\nvoid InsertionSort(int* A, int n) &#123;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tint key &#x3D; A[i], j &#x3D; i - 1;\n\t\twhile (j &gt;&#x3D; 0 &amp;&amp; A[j] &gt; key) &#123;\n\t\t\tA[j + 1] &#x3D; A[j];\n\t\t\tj--;\n\t\t&#125;\n\t\tA[j + 1] &#x3D; key;\n\t&#125;\n&#125;\n\nvoid Merge(int* A, int p, int q, int r) &#123;\n\tint n1 &#x3D; q - p + 1, n2 &#x3D; r - q, i &#x3D; 0, j &#x3D; 0;\n\tint* B &#x3D; new int[n1 + 1];\n\tint* C &#x3D; new int[n2 + 1];\n\tB[n1] &#x3D; INF;\n\tC[n2] &#x3D; INF;\n\tfor (int i &#x3D; 0; i &lt; n1; i++) B[i] &#x3D; A[p + i];\n\tfor (int i &#x3D; 0; i &lt; n2; i++) C[i] &#x3D; A[q + i + 1];\n\tfor (int k &#x3D; p; k &lt;&#x3D; r; k++) &#123;\n\t\tif (B[i] &lt;&#x3D; C[j]) &#123;\n\t\t\tA[k] &#x3D; B[i];\n\t\t\ti++;\n\t\t&#125;\n\t\telse &#123;\n\t\t\tA[k] &#x3D; C[j];\n\t\t\tj++;\n\t\t&#125;\n\t&#125;\n\tdelete[] B;\n\tdelete[] C;\n&#125;\n\nvoid MergeSort(int* A, int p, int r) &#123;\n\tif (p &lt; r) &#123;\n\t\tint q &#x3D; (p + r) &#x2F; 2;\n\t\tMergeSort(A, p, q);\n\t\tMergeSort(A, q + 1, r);\n\t\tMerge(A, p, q, r);\n\t&#125;\n&#125;\n\nint Partition(int* A, int p, int r) &#123;\n\tint q &#x3D; p;\n\tfor (int u &#x3D; p; u &lt; r; u++) &#123;\n\t\tif (A[u] &lt;&#x3D; A[r]) &#123;\n\t\t\tint temp &#x3D; A[u];\n\t\t\tA[u] &#x3D; A[q];\n\t\t\tA[q] &#x3D; temp;\n\t\t\tq++;\n\t\t&#125;\n\t&#125;\n\tint temp &#x3D; A[r];\n\tA[r] &#x3D; A[q];\n\tA[q] &#x3D; temp;\n\treturn q;\n&#125;\n\nvoid QuickSort(int* A, int p, int r) &#123;\n\tif (p &lt; r) &#123;\n\t\tint q &#x3D; Partition(A, p, r);\n\t\tQuickSort(A, p, q - 1);\n\t\tQuickSort(A, q + 1, r);\n\t&#125;\n&#125;\n\nint main(int argc, char** argv) &#123;\n\tint n &#x3D; 0, lt &#x3D; 0;\n\tclock_t start, end;\n\tdouble temptime &#x3D; 0.0, sum &#x3D; 0.0;\n\tdouble sorttime[5] &#x3D; &#123; 0.0 &#125;;\n\tvector&lt;double&gt; tempsorttime;\n\n\tcout &lt;&lt; &quot;Enter the Input data scale : &quot;;\n\tcin &gt;&gt; n;\n\tcout &lt;&lt; &quot;Enter the Loop time : &quot;;\n\tcin &gt;&gt; lt;\n\n\tint* A &#x3D; new int[n];\n\n\ttempsorttime.clear();\n\tfor (int i &#x3D; 0; i &lt; lt; i++) &#123;\n\t\tsrand((int)time(NULL));\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\tA[i] &#x3D; rand();\n\n\t\tstart &#x3D; clock();\n\t\tInsertionSort(A, n);\n\t\tend &#x3D; clock();\n\t\ttemptime &#x3D; (double)(end - start);\n\t\ttempsorttime.push_back(temptime);\n\t\tcout &lt;&lt; &quot;Insertion Sort time : &quot; &lt;&lt; temptime &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\t&#125;\n\tsum &#x3D; 0.0;\n\tfor (auto i : tempsorttime) &#123;\n\t\tsum +&#x3D; i;\n\t&#125;\n\tsorttime[0] &#x3D; (double)sum &#x2F; lt;\n\n\ttempsorttime.clear();\n\tfor (int i &#x3D; 0; i &lt; lt; i++) &#123;\n\t\tsrand((int)time(NULL));\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\tA[i] &#x3D; rand();\n\n\t\tstart &#x3D; clock();\n\t\tSelectionSort(A, n);\n\t\tend &#x3D; clock();\n\t\ttemptime &#x3D; (double)(end - start);\n\t\ttempsorttime.push_back(temptime);\n\t\tcout &lt;&lt; &quot;Selection Sort time : &quot; &lt;&lt; temptime &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\t&#125;\n\tsum &#x3D; 0.0;\n\tfor (auto i : tempsorttime) &#123;\n\t\tsum +&#x3D; i;\n\t&#125;\n\tsorttime[1] &#x3D; (double)sum &#x2F; lt;\n\n\ttempsorttime.clear();\n\tfor (int i &#x3D; 0; i &lt; lt; i++) &#123;\n\t\tsrand((int)time(NULL));\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\tA[i] &#x3D; rand();\n\n\t\tstart &#x3D; clock();\n\t\tMergeSort(A, 0, n - 1);\n\t\tend &#x3D; clock();\n\t\ttemptime &#x3D; (double)(end - start);\n\t\ttempsorttime.push_back(temptime);\n\t\tcout &lt;&lt; &quot;Merge Sort time : &quot; &lt;&lt; temptime &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\t&#125;\n\tsum &#x3D; 0.0;\n\tfor (auto i : tempsorttime) &#123;\n\t\tsum +&#x3D; i;\n\t&#125;\n\tsorttime[2] &#x3D; (double)sum &#x2F; lt;\n\n\ttempsorttime.clear();\n\tfor (int i &#x3D; 0; i &lt; lt; i++) &#123;\n\t\tsrand((int)time(NULL));\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\tA[i] &#x3D; rand();\n\n\t\tstart &#x3D; clock();\n\t\tQuickSort(A, 0, n - 1);\n\t\tend &#x3D; clock();\n\t\ttemptime &#x3D; (double)(end - start);\n\t\ttempsorttime.push_back(temptime);\n\t\tcout &lt;&lt; &quot;Quick Sort time : &quot; &lt;&lt; temptime &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\t&#125;\n\tsum &#x3D; 0.0;\n\tfor (auto i : tempsorttime) &#123;\n\t\tsum +&#x3D; i;\n\t&#125;\n\tsorttime[3] &#x3D; (double)sum &#x2F; lt;\n\n\ttempsorttime.clear();\n\tfor (int i &#x3D; 0; i &lt; lt; i++) &#123;\n\t\tsrand((int)time(NULL));\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\tA[i] &#x3D; rand();\n\n\t\tstart &#x3D; clock();\n\t\tRandomQuickSort(A, 0, n - 1);\n\t\tend &#x3D; clock();\n\t\ttemptime &#x3D; (double)(end - start);\n\t\ttempsorttime.push_back(temptime);\n\t\tcout &lt;&lt; &quot;Randomized Quick Sort time : &quot; &lt;&lt; temptime &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\t&#125;\n\tsum &#x3D; 0.0;\n\tfor (auto i : tempsorttime) &#123;\n\t\tsum +&#x3D; i;\n\t&#125;\n\tsorttime[4] &#x3D; (double)sum &#x2F; lt;\n\n\tcout &lt;&lt; endl &lt;&lt; &quot;Final time:&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Insertion Sort : &quot; &lt;&lt; sorttime[0] &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Selection Sort : &quot; &lt;&lt; sorttime[1] &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Merge Sort : &quot; &lt;&lt; sorttime[2] &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Quick Sort : &quot; &lt;&lt; sorttime[3] &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Randomized Quick Sort : &quot; &lt;&lt; sorttime[4] &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\n\tdelete[] A;\n\tA &#x3D; NULL;\n\tsystem(&quot;pause&quot;);\n\treturn 0;\n&#125;\n","slug":"Algorithm-Unlocked-Sort-Test-Source-Code","date":"2021-10-30T16:13:46.000Z","categories_index":"算法基础,Algorithms Unlocked,学习笔记","tags_index":"Notes,Sort,排序算法","author_index":"Minecraft1248"},{"id":"2e4dd07c9efba521a4f50b17ccdbb5c4","title":"《算法基础》学习笔记-线性搜索算法","content":" 《算法基础》学习笔记\n 一.线性搜索算法\n","slug":"Algorithm-Unlocked-Note-2021-10-29-linear-search","date":"2021-10-29T10:28:24.000Z","categories_index":"算法基础,Algorithms Unlocked,学习笔记","tags_index":"Notes,Sort,线性搜索算法","author_index":"Minecraft1248"},{"id":"c556e014e1cd2aeced9fbf030f4918f6","title":"Helium项目简介","content":" Helium项目简介\n 一.什么是Helium\n​\t\tHelium是一个由Fallen-Breath/MCDReforged项目所启发的,由C++编写的Minecraft服务端控制工具.与MCDR类似的是,Helium同样不需要对Minecraft服务端进行修改即可提供一个可自定义的扩展系统.\n​\t\tHelium本身是其前身项目的重写(Minecraft1248/MCDReforged_By_CPP,现仓库已删除),项目按照GNU GPL-3.0协议开放源代码.目的是为了提供一套独立与MCDR的解决方案,以及提供一个相对于MCDR更加快速,简洁和可自定义的但牺牲了可移植性和开发维护的简易性的选择.\n​\t\t目前我们没有及MCDR兼容性集成进Helium中的打算(防止潜在的LGPL-2.0和GPL-3.0的协议冲突),我们可能会用一个Helium扩展来实现与MCDR的兼容.\n​\t\tHelium目前还没有开发出一个真正可用的版本,所以如果你对我们的项目感兴趣并且想在自己的Minecraft服务器上使用,我们建议你先行使用MCDR作为临时替代.\n​\t\t在此感谢以下项目的开发者,他们开发的下列项目大大帮助了我们的项目开发:\n​\t\t\tkpeeters/tree.hh一个相当优秀的STL-like树实现\n​\t\t\tAmokHuginnsson/replxx类似于GNU Realine的命令行工具库\n​\t\t\tgabime/spdlog快速,简洁的C++日志库\n​\t\t\tleethomason/tinyxml2简洁,高效的XML文件解析库\n 二.想参与Helium的开发工作?\n​\t\t通过我的邮箱联系我,并注明来意:minecraft1248_bilibili@outlook.com\n 三.相关链接\n​\t\tGithub Repository:Minecraft1248/Helium\n​\t\tGitee仓库:竹若泠/Helium\n","slug":"helium-project-introduction-2021-10-9","date":"2021-10-09T15:51:59.000Z","categories_index":"Helium","tags_index":"Helium,Github","author_index":"Minecraft1248"},{"id":"4b62e9d40a3e4e08517eb0d7ae0aa728","title":"《算法基础》学习笔记-比较排序算法","content":" 《算法基础》学习笔记\n 二.比较排序算法\n 0.定义:\n​\t只使用对排序关键字的比较操作来进行排序的算法,称为比较排序算法.\n​\t此处仅讨论对将数组排序成递增顺序的排序算法,即数组中每个元素均大于等于其前驱.要进行递增的比较排序,需要定义排序关键字的&quot;小于&quot;等判断的意义.\n​\t在排序时,参与排序比较的数据称之为排序关键字,与排序关键字相关联的数据称为卫星数据.\n 1.选择排序\n 选择排序的C++实现:\nvoid SelectionSort(int* A, int n)&#123;\t&#x2F;&#x2F;A:待排序数组指针, n:数组内元素个数\n\tfor(int i &#x3D; 0; i &lt; n; i ++)&#123;\n\t\tint min &#x3D; A[i], minindex &#x3D; i;\n\t\tfor(int j &#x3D; i + 1; j &lt; n; j ++)&#123;\t&#x2F;&#x2F;找出A[i+1...n-1]中最小值下标\n\t\t\tif(A[j] &lt; min)&#123;\n\t\t\t\tmin&#x3D; A[j];\n\t\t\t\tminindex &#x3D; j;\n\t\t\t&#125;\n\t\t&#125;\n\t\tint temp &#x3D; A[i];\t&#x2F;&#x2F;交换最小值与A[i]的值\n\t\tA[i] &#x3D; A[minindex];\n\t\tA[minindex] &#x3D; temp;\n\t&#125;\n&#125;\n 算法分析:\n​\t假设一开始整个数组A是无序的,故找出A[0…n-1]当中的最小值,将其调换至数组起始,则此时A[1…n-1],即除A[0]外的整个数组,其所包含的元素均大于等于A[0]的值,故此时A[0]有序,A[1…n-1]无序,故再在A[1…n-1]当中找出最小值并调换至A的有序部分的末端,依此类推.\n 运行时间及循环不等式:\n 选择排序的循环不等式:\n​\t当SelectionSort()中循环开始时,A[0…i]中元素为A的前i个有序排列的最小元素.\n 选择排序的运行时间:\n​\t当i=0时,SelectionSort()的内层循环变量从1自加至n,共执行n-1次,易知内层循环总会执行n-1-i次,又因为i由0自加至n,故内层循环一共被执行n-1次.设其余操作均花费常量时间.故:\nTinner=(n−1)+(n−2)+…+2+1T_{inner}=(n-1)+(n-2)+\\ldots+2+1\nTinner​=(n−1)+(n−2)+…+2+1\n​\t这是一个等差数列求和,故由:\nk+(k−1)+(k−2)+…+2+1=k(k+1)2,其中k∈N+k+(k-1)+(k-2)+\\ldots+2+1=\\frac {k(k+1)}2,其中k\\in N+\nk+(k−1)+(k−2)+…+2+1=2k(k+1)​,其中k∈N+\n​\t有:\nT=(n−1)+(n−2)+…+2+1=(n−1)(n−1+1)2=n(n−1)2=(n2−n)2T=(n-1)+(n-2)+\\ldots+2+1=\\frac {(n-1)(n-1+1)}2=\\frac {n(n-1)}2=\\frac {(n^2-n)}2\nT=(n−1)+(n−2)+…+2+1=2(n−1)(n−1+1)​=2n(n−1)​=2(n2−n)​\nT(n)=θ(n2)T(n)=\\theta (n^2)\nT(n)=θ(n2)\n 总结\n​\t在SelectionSort()运行过程中的内循环中if语句会执行n^2次,但仅仅移动了元素n次,若元素移动耗时(比如磁盘)或元素大小太大时,可以考虑使用选择排序.\n 2.插入排序\n 插入排序的C++实现:\nvoid InsertionSort(int* A, int n)&#123;\t&#x2F;&#x2F;输入与相同选择排序x&#39;t\n\tfor(int i &#x3D; 1; i &lt; n; i ++)&#123;\n\t\tint key &#x3D; A[i], j &#x3D; i - 1;\t&#x2F;&#x2F;选择要向左比较的数\n\t\twhile(j &gt;&#x3D; 0 &amp;&amp; A[j] &gt; key)&#123;\n\t\t\tA[j + 1] &#x3D; A[j];\t&#x2F;&#x2F;将比key大的数向右移\n\t\t\tj --;\n\t\t&#125;\n\t\tA[j + 1] &#x3D; key;\t&#x2F;&#x2F;将key插入向右移空出的空位\n\t&#125;\n&#125;\n 算法分析:\n​\t假设整个数组A是无序的,令i由1自加到n,让每个A[i]与子数组A[0…i-1],即A[i]的所有前驱,从A[i-1]比较至A[0],若其前驱大于A[i],则令其向右移一个单位,若其前驱小于A[i]或访问数组即将越界,停止比较,并将A[i]插入右移元素空出的空位.\n 运行时间及循环不变式:\n 插入排序的循环不变式:\n​\t当InsertionSort()中的循环开始迭代时,A[0…i-2]包含其未被排序时子数组A[0…i-1]的全部元素,但此时A[0…i-2]已排好序.\n 插入排序的运行时间:\n​\t1.最坏情况:\n​\t\t当InsertionSort()中的外层循环开始第一次执行时,A[i]应赋值给A[0],即j从i-1自减至0,内层循环执行i次,此时内层循环因j&gt;=0不成立,或数组访问越界而停止.故外层循环共执行n-1次,设其他操作均花费常量时间.则有执行时间:\nT(n)=1+2+…+(n−2)+(n−1)=(n−1)(n−1+1)2=(n2−n)2T(n)=1+2+\\ldots +(n-2)+(n-1)=\\frac {(n-1)(n-1+1)}2=\\frac {(n^2-n)}2\nT(n)=1+2+…+(n−2)+(n−1)=2(n−1)(n−1+1)​=2(n2−n)​\n​\t故最坏情况下:\nT(n)=θ(n2)T(n)=\\theta (n^2)\nT(n)=θ(n2)\n​\t2.最好情况:\n​\t\t此时内层循环会花费常量时间,故有最好情况下:\nT(n)=θ(n)T(n)=\\theta (n)\nT(n)=θ(n)\n​\t综上所述,运行时间为最好情况θ(n),最坏情况θ(n^2).\n 3.归并排序\n 归并排序的C++实现:\n#define INF 0x7FFFFFFF\n\nvoid Merge(int* A, int p, int q, int r)&#123;\t&#x2F;&#x2F;A:待归并数组指针,p:归并区段起始下标,q:归并区段中间点下标,r:归并区段末尾下标\n\tint n1 &#x3D; q - p + 1, n2 &#x3D; r - q, i &#x3D; 0, j &#x3D; 0;\n\tint* B &#x3D; new int[n1 + 1];\t&#x2F;&#x2F;制作两个堆\n\tint* C &#x3D; new int[n2 + 1];\n\tB[n1] &#x3D; INF;\t&#x2F;&#x2F;信号量\n\tC[n2] &#x3D; INF;\n\tfor(int i &#x3D; 0; i &lt; n1; i ++) B[i] &#x3D; A[p + i];\t&#x2F;&#x2F;拷贝元素\n\tfor(int i &#x3D; 0; i &lt; n2; i ++) C[i] &#x3D; A[q+i+1];\n\tfor(int k &#x3D; p; k &lt;&#x3D; r; k ++)&#123;\n\t\tif(B[i] &lt;&#x3D; C[j]) &#123;\n\t\t\tA[k] &#x3D; B[i];\n\t\t\ti ++;\n\t\t&#125; else&#123;\n\t\t\tA[k] &#x3D; C[j];\n\t\t\tj ++;\t\n\t\t&#125;\n\t&#125;\n\tdelete[] B;\n\tdelete[] C;\n&#125;\n\nvoid MergeSort(int* A, int p, int r)&#123;\t&#x2F;&#x2F;A:待排序数组指针,p:起始下标,r:结束下标\n\tif(p &lt; r)&#123;\t&#x2F;&#x2F;若p&gt;&#x3D;r时,A已有序,直接返回\n\t\tint q &#x3D; (p + r) &#x2F; 2;\t&#x2F;&#x2F;分解问题\n\t\tMergeSort(A, p, q);\t&#x2F;&#x2F;递归求解子问题\n\t\tMergeSort(A, q + 1, r);\n\t\tMerge(A, p, q, r);\t&#x2F;&#x2F;合并子问题解\n\t&#125;\n&#125;\n\n 算法分析:\n​\t分治法的一般概述:\n​\t1.分解:把一个问题分解为多个子问题,这些子问题是更小实例上的原问题.\n​\t2.解决:递归地求解子问题,当子问题足够小时,按照基础情况来求解.\n​\t3.合并:把子问题的解合并为原问题的解.\n​\t分治法在归并排序中的应用:\n​\t1.分解:通过找到位于p和r中间位置的下标q来对问题进行分解,q等于p加r的和除以2,并向下取整.\n​\t2.解决:对分解步骤的两个子问题的数组进行递归排序,即对A[p…q]和A[q+1…r]分别进行递归排序.\n​\t3.合并:将A[p…q]和A[q+1…r]这两个已经排好序的数组进行合并,使得A[p…r]排好序.\n​\t当子问题的数组中的元素个数小于等于1时(即p &gt;= r时),基础情况发生,因为一个只包含1个元素或空的数组总是有序的.\n​\t4.合并方式:\n​\t将A[p…q]和A[q+1…r]中的元素分别制作为两个堆,并将&quot;无限&quot;(此处的无限可取排序关键字永远不会等于的值)插入堆底,易知两个堆堆顶元素均为其所在堆中最小元素,故A[p],A[p+1]的值应为B[0],C[0],且A[p] &lt;= A[p+1],依此类推.\n​\t用此方法归并时,易知数组A[p…r]中的每个元素均被移动了2次,一次是制作堆时,另一次是将其由堆归入A时,故当A[p…r]包含n个元素时,归并这一过程移动了2n次元素且至多比较n次,即线性时间内的归并.\n​\t用此方法进行的归并不是原址的,虽然我们可以实现线性时间内的原址归并,但是实现方式相当复杂.\n​\t为了避免每归并一对元素时均要检查是否数组访问越界,我们在数组B,C最后插入一个大于任意元素的值,与SentinelLinearSearch()相类似.这里使用了#define INF 0x7FFFFFFF来取int类型占4字节时的最大值,以INF作为标记的排序关键字,以便一个带有INF的的关键字是数组中的剩余最小元素时,无需检查哪个数组还有最小的剩余元素.\n​\t因为B,C中元素个数差不会大于1,故当B,C中所有的剩余元素归并完时,B,C的最小剩余元素均为INF,但此时循环因为k &gt; r而退出,因此无需再次比较剩余元素大小.\n 运行时间\n​\t归并排序的运行时间T(n)来自分治法的三个部分耗费时间的累加和:\n​\t1.分解花费常量时间来计算下标q.\n​\t2.解决包括两个数组的递归调用,每个子数组有n/2个元素.定义每个子数组递归调用的花费时间为T(n/2).\n​\t3.通过合并排序好的子数组来合并这两个递归调用的结果需要花费θ(n)时间.\n​\t因与合并所需的θ(n)时间相比,分解所需时间只是一个低阶项,故可以将分解时间并入合并时间,即分解和合并共花费θ(n)时间,解决步骤花费2*T(n/2)时间,故有:\nT(n)=2T(T2)+θ(n)T(n)=2T(\\frac T2)+\\theta (n)\nT(n)=2T(2T​)+θ(n)\n​\t在这个等式中,T(n)被用于描述自己,我们称这样一个等式为递归式,因为归并排序为一个应用了分治法的算法,故我们可以用一个称之为主方法的标准化方法来将T(n)表达为非递归形式.\n​\t主方法:\n​\t对于形为如下的递归式:\nT(n)=aT(nb)+f(n),a∈[1,+∞),b∈(1,+∞),f(n)为渐近正函数T(n)=aT(\\frac nb)+f(n),a\\in [1,+\\infin),b\\in (1,+\\infin),f(n)为渐近正函数\nT(n)=aT(bn​)+f(n),a∈[1,+∞),b∈(1,+∞),f(n)为渐近正函数\n​\t其中a,b为参数,且n/b可能不是整数,但是对n/b进行向上或向下取整不影响递归式的渐近性质.\n​\t主方法主要依赖于主定理:\n令a⩾1和b&gt;1是常数,f(n)是一个函数,T(n)是定义在非负整数上的递归式:T(n)=aT(nb)+f(n)令a⩾1和b&gt;1是常数,f(n)是一个函数,T(n)是定义在非负整数上的递归式:\nT(n) = aT(\\frac{n}{b}) + f(n)\n令a⩾1和b&gt;1是常数,f(n)是一个函数,T(n)是定义在非负整数上的递归式:T(n)=aT(bn​)+f(n)\n其中我们将nb解释为⌈nb⌉或⌊nb⌋。那么T(n)有如下渐进界：其中我们将\\frac{n}{b} 解释为 \\lceil\\frac{n}{b}\\rceil或\\lfloor\\frac{n}{b}\\rfloor。那么T(n)有如下渐进界：\n其中我们将bn​解释为⌈bn​⌉或⌊bn​⌋。那么T(n)有如下渐进界：\n1.若对某个常数ε&gt;0有f(n)=O(nlogba−ε),则T(n)=Θ(nlogba)f(n)多项式意义上的小于(渐进小于)nlogban1.若对某个常数\\varepsilon &gt;0有f(n)=O(n^{log_{b}a-\\varepsilon}),则T(n) = \\Theta(n^{log_{b}a})f(n)多项式意义上的小于(渐进小于)n^{log_{b}a}n\n1.若对某个常数ε&gt;0有f(n)=O(nlogb​a−ε),则T(n)=Θ(nlogb​a)f(n)多项式意义上的小于(渐进小于)nlogb​an\n2.若f(n)=Θ(nlogbalgkn),则T(n)=Θ(nlogbalgk+1n)2.若f(n) = \\Theta(n^{log_{b}a}lg^kn),则T(n) = \\Theta(n^{log_{b}a}lg^{k+1}n)\n2.若f(n)=Θ(nlogb​algkn),则T(n)=Θ(nlogb​algk+1n)\n(若对某个常数ε&gt;0有f(n)=Ω(nlogba+ε),且对于某个常数c&lt;1和所有充分大的n有af(nb)⩽c,那T(n)=Θ(f(n)).(f(n)多项式意义上的大于(渐进大于)nlogba)(若对某个常数\\varepsilon &gt; 0有f(n) = \\Omega(n^{log_{b}a+\\varepsilon}),且对于某个常数c&lt;1和所有充分大的n有af(\\frac{n}{b}) \\leqslant c,那T(n)=\\Theta(f(n)).(f(n)多项式意义上的大于(渐进大于)n^{log_{b}a})\n(若对某个常数ε&gt;0有f(n)=Ω(nlogb​a+ε),且对于某个常数c&lt;1和所有充分大的n有af(bn​)⩽c,那T(n)=Θ(f(n)).(f(n)多项式意义上的大于(渐进大于)nlogb​a)\n​\t故可知T(n)=θ(nlgn).该运行时间适合于归并排序的所有情况.\n 4.快速排序\n 快速排序的C++实现:\nint Partition(int* A, int p, int r)&#123;\n\tint q &#x3D; p;\n\tfor(int u &#x3D; p; u &lt; r; u ++)&#123;\n\t\tif(A[u] &lt;&#x3D; A[r])&#123;\n\t\t\tint temp &#x3D; A[u];\n\t\t\tA[u] &#x3D; A[q];\n\t\t\tA[q] &#x3D; temp;\n\t\t\tq ++;\n\t\t&#125;\n\t&#125;\n\tint temp &#x3D; A[r];\n\tA[r] &#x3D; A[q];\n\tA[q] &#x3D; temp;\n\treturn q;\n&#125;\n\nvoid QuickSort(int* A, int p, int r)&#123;\n\tif(p &lt; r)&#123;\n\t\tint q &#x3D; Partition(A, p, r);\n\t\tQuickSort(A, p, q - 1);\n\t\tQuickSort(A, q + 1, r);\n\t&#125;\n&#125;\n 算法分析:\n​\t快速排序也使用了分治法,故有描述如下:\n​\t1.分解:首先选择A[p…r]中的一个元素,称为主元,对数组A中除了主元外的元素进行排序,让小于等于主元的元素排在主元的左侧,让所有大于主元的元素排在主元的右侧,我们称这一过程为划分.注意,划分后主元左侧的所有元素和主元右侧的所有元素均是无序的.\n​\t2.解决:通过递归地对主元左侧的和右侧的元素进行排序来解决子问题,也就是说,若分解步骤将主元移动到位置q,随后就会递归地对从p到q-1的元素进行排序,同时对q+1到r的元素进行排序.\n​\t3.合并:经过前两个步骤后,数组A已经有序,因此不需合并.\n​\t与归并排序相同,当待排序的子数组元素数量小于等于1时,基础情况发生.\n​\t快速排序的关键是划分数组,与归并排序相同的是,我们同样能在θ(n)时间内划分n个元素,选择数组A中的末尾元素,即A[r],作为主元,任意时刻,A[p…r-1]中的元素将会被划分到下列4个组的一个组中,且这四个组均位于A[p…r]中.按空间顺序从前向后排列依次是:\n​\t组L(左侧组):此组中所包含的元素均小于等于主元,即A[p…q-1].\n​\t组R(右侧组):此组中所包含的元素均大于主元,即A[q…u-1].\n​\t组U(未知组):此组中所包含的元素还未与主元比较,即A[u…r-1].\n​\t组P(主元):即主元,或A[r].\n​\t快速排序自左向右检查组U中的元素,将它们与主元进行比较,并将它们移动到组L或组R中,一旦检查到主元位置处,就停止所有操作.与主元进行比较的元素始终是组U中最左侧的元素.\n​\t(1).若组U中的元素大于主元,就将组R和组U之间的界限向右移1个单位.故此时比较的组U中元素成为组R中最后的元素.\n​\t(2).若组U中的元素小于等于主元,则将此元素与组R最前的元素进行调换,并将组L和组R,组R和组U之间的界限均向右移1个单位.\n​\t(3).一旦检查到主元位置,就将主元与组R最前的元素调换.\n​\t快速排序将数组中每个除主元外的元素与主元比较1次,当元素小于等于主元时会产生一次调换.因此,划分n个元素时,快速排序至多进行n-1次比较(主元无需比较),至多进行n次调换.并且划分这一过程是完全原址的.\n 运行时间及循环不变式\n 快速排序的循环不变式:\n​\t划分过程中四个组的划分方式即为此算法的循环不变式,这里不再赘述.\n 快速排序的运行时间:\n​\t设每次比较和调换操作均花费常量时间,故对包含n个元素的子数组进行划分操作需要的总时间是θ(n).\n​\t在最坏情况下,即A为逆序的,划分得到的大小是相当不均衡的,若除了主元之外的所有元素均小于主元,则划分的结果是A[p…r-1],即除去主元的剩余部分,且QuickSort()最终会返回在q中的索引r值.这种情况下,A[q+1…r]是空的,且A[p…q-1]仅仅比A[p…r]少一个元素.对空的子数组进行递归调用需要θ(1)时间,对于划分,我们可以将θ(1)并入θ(n)时间内,但是如果A[p…r]有n个元素,那么A[p…q-1]有n-1个元素,故对A[p…q-1]进行递归调用需要花费T(n-1)时间,故有:\nT(n)=T(n−1)+θ(n)⇒T(n)=θ(n2)T(n)=T(n-1)+\\theta (n)\\Rightarrow T(n)=\\theta (n^2)\nT(n)=T(n−1)+θ(n)⇒T(n)=θ(n2)\n​\t另一方面,若每次都能得到一个均匀的划分,则每个子数组最多有n/2个元素,故有:\nT(n)=2T(n2)+θn⇒T(n)=θ(nlgn)T(n)=2T(\\frac n2)+\\theta n\\Rightarrow T(n)=\\theta (nlgn)\nT(n)=2T(2n​)+θn⇒T(n)=θ(nlgn)\n​\t一般而言,当输入数组为完全随机产生时,T(n)≈θ(nlgn).\n​\t我们也可以在A[p…r]中随机选取3个元素,并将这3个元素中值介于其他两个元素的元素设为主元,即与A[r]调换,这称为随机快速排序,上文所述称为确定的快速排序.\n 5.多种比较排序算法的用时比较\n 理论用时:\n\n\n\n比较排序算法\n最坏情况下运行时间\n最好情况下运行时间\n最坏情况下调换次数\n是否原址\n\n\n\n\n选择排序\nθ(n^2)\nθ(n^2)\nθ()\n是\n\n\n插入排序\nθ(n^2)\nθ(n)\nθ(n^2)\n是\n\n\n归并排序\nθ(nlgn)\nθ(nlgn)\nθ(nlgn)\n否\n\n\n快速排序\nθ(n^2)\nθ(nlgn)\nθ(n^2)\n是\n\n\n\n 实际用时:\n​\t实现语言:C++14\n​\t编译器:MSVC v143 优化/O2\n​\t操作系统:Windows 11 家庭中文版 22468.1000\n​\t处理器:Intel Core i9-8950HK 2.90GHz\n​\t内存:32GB 2667MHz\n​\t数据规模:由50至500000个随机产生的int类型元素,范围由0至2147483647\n​\t测试方式:每种算法独立运行20次取花费时间平均值\n\n\n\n算法\nn=50\nn=100\nn=500\nn=1000\nn=5000\nn=10000\nn=50000\nn=100000\nn=500000\n\n\n\n\n插入排序\n&lt;0.01ms\n&lt;0.01ms\n&lt;0.01ms\n0.2ms\n2.65ms\n10.55ms\n249.25ms\n1151.05ms\n39167.6ms\n\n\n选择排序\n&lt;0.01ms\n&lt;0.01ms\n0.05ms\n0.3ms\n10.1ms\n39.2ms\n907.6ms\n3805.5ms\n126624ms\n\n\n归并排序\n0.05ms\n0.05ms\n0.1ms\n0.2ms\n2.1ms\n4.8ms\n13.6ms\n30.6ms\n115.8ms\n\n\n确定的快速排序\n&lt;0.01ms\n&lt;0.01ms\n&lt;0.01ms\n0.15ms\n0.15ms\n0.25ms\n3.55ms\n7.5ms\n29.6ms\n\n\n随机快速排序\n&lt;0.01ms\n&lt;0.01ms\n0.1ms\n0.1ms\n0.45ms\n0.75ms\n4.4ms\n8.95ms\n39.6ms\n\n\n\n这个测试结果跟《算法基础》测的的数据有些偏差,譬如选择排序耗时几乎是相同情况下插入排序的3-4倍,甚至更多,随机快速排序比相同情况下确定的快速排序要慢等情况,碍于篇幅,我会在另一篇单独的文章中放出实现源代码.\n另:Aurora主题似乎还不支持使用MathJax渲染数学公式,也只能这样了w.\n","slug":"Algorithm-Unlocked-Note-2021-10-29-sort","date":"2021-10-29T10:27:54.000Z","categories_index":"算法基础,Algorithms Unlocked,学习笔记","tags_index":"Notes,Sort,排序算法","author_index":"Minecraft1248"},{"id":"be472a5bafbe1f7cb019e7ee835fb39d","title":"Helium项目开发进度-2021/10/10","content":"首先,要提前说明一下的是,Helium是对MCDReforged_By_CPP的一次几乎完全的重写,所以当你看到我们的开发进度特别慢的时候也不要感到太惊讶plz,我们的开发人员真的个个学业压力巨大(落泪).\n 已经完成或大体成型的代码\n配置文件读写部分:\n-config.cpp\n-config.h\nmain()函数部分:\n-Helium.cpp\n服务器进程管理及相关配置文件读写部分:\n-minecraftserver.cpp\n-minecraftserver.h\n权限文件读写及管理部分:\n-permission.cpp\n-permission.h\n其他:\n-utils.cpp\n-utils.h\n-xmlutils.cpp\n-xmlutils.h\n 已经初步成型正在完善的代码\n指令解析/指令树/CLI指令自动补全等:\n-commands.cpp\n-commands.h\n事件系统:\n-event.cpp\n-event.h\n扩展管理及加载部分:\n-extension.cpp\n-extension.h\nMinecraft服务器输出解析部分:\n-parse.cpp\n-parse.h\n 仍在开发早期或需要修改的代码\nAPI函数导出部分:\n-exportfunction.cpp\n-exportfunction.h\n对spdlog库的封装:\n-logger.cpp\n-logger.h\n看门狗:\n-watchdog.cpp\n-watchdog.h\nthat’s all\n","slug":"helium-develop-progress-2021-10-10","date":"2021-10-09T16:53:28.000Z","categories_index":"Helium","tags_index":"Helium,Github","author_index":"Minecraft1248"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n Quick Start\n Create a new post\n$ hexo new \"My New Post\"\nMore info: Writing\n Run server\n$ hexo server\nMore info: Server\n Generate static files\n$ hexo generate\nMore info: Generating\n Deploy to remote sites\n$ hexo deploy\nMore info: Deployment\n","slug":"hello-world","date":"2021-10-09T13:19:59.472Z","categories_index":"","tags_index":"","author_index":"Minecraft1248"}]