{"title":"杂记-常见排序算法实现及其浅析","uid":"7b96841ab300f1a32883b72d5fd4ae72","slug":"常见排序算法实现及浅析","date":"2021-11-06T10:16:59.000Z","updated":"2021-11-06T02:57:14.894Z","comments":true,"path":"api/articles/常见排序算法实现及浅析.json","keywords":"Minecraft1248","cover":null,"content":"<h1 id=\"常见排序算法实现及浅析\"><a class=\"markdownIt-Anchor\" href=\"#常见排序算法实现及浅析\"></a> 常见排序算法实现及浅析</h1>\n<h1 id=\"一比较排序\"><a class=\"markdownIt-Anchor\" href=\"#一比较排序\"></a> 一.比较排序</h1>\n<h3 id=\"1交换排序\"><a class=\"markdownIt-Anchor\" href=\"#1交换排序\"></a> 1.交换排序</h3>\n<h4 id=\"冒泡排序\"><a class=\"markdownIt-Anchor\" href=\"#冒泡排序\"></a> 冒泡排序</h4>\n<h5 id=\"c实现\"><a class=\"markdownIt-Anchor\" href=\"#c实现\"></a> C++实现</h5>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\"><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h5 id=\"算法描述\"><a class=\"markdownIt-Anchor\" href=\"#算法描述\"></a> 算法描述</h5>\n<h4 id=\"快速排序\"><a class=\"markdownIt-Anchor\" href=\"#快速排序\"></a> 快速排序</h4>\n<h5 id=\"c实现-2\"><a class=\"markdownIt-Anchor\" href=\"#c实现-2\"></a> C++实现</h5>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int Partition(int* A, int p, int r)&#123;\n\tint q &#x3D; p;\n\tfor(int u &#x3D; p; u &lt; r; u ++)&#123;\n\t\tif(A[u] &lt;&#x3D; A[r])&#123;\n\t\t\tint temp &#x3D; A[u];\n\t\t\tA[u] &#x3D; A[q];\n\t\t\tA[q] &#x3D; temp;\n\t\t\tq ++;\n\t\t&#125;\n\t&#125;\n\tint temp &#x3D; A[r];\n\tA[r] &#x3D; A[q];\n\tA[q] &#x3D; temp;\n\treturn q;\n&#125;\n\nvoid QuickSort(int* A, int p, int r)&#123;\n\tif(p &lt; r)&#123;\n\t\tint q &#x3D; Partition(A, p, r);\n\t\tQuickSort(A, p, q - 1);\n\t\tQuickSort(A, q + 1, r);\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"算法描述-2\"><a class=\"markdownIt-Anchor\" href=\"#算法描述-2\"></a> 算法描述</h5>\n<h3 id=\"2插入排序\"><a class=\"markdownIt-Anchor\" href=\"#2插入排序\"></a> 2.插入排序</h3>\n<h4 id=\"插入排序\"><a class=\"markdownIt-Anchor\" href=\"#插入排序\"></a> 插入排序</h4>\n<h5 id=\"c实现-3\"><a class=\"markdownIt-Anchor\" href=\"#c实现-3\"></a> C++实现</h5>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void InsertionSort(int* A, int n)&#123;\t&#x2F;&#x2F;输入与相同选择排序x&#39;t\n\tfor(int i &#x3D; 1; i &lt; n; i ++)&#123;\n\t\tint key &#x3D; A[i], j &#x3D; i - 1;\t&#x2F;&#x2F;选择要向左比较的数\n\t\twhile(j &gt;&#x3D; 0 &amp;&amp; A[j] &gt; key)&#123;\n\t\t\tA[j + 1] &#x3D; A[j];\t&#x2F;&#x2F;将比key大的数向右移\n\t\t\tj --;\n\t\t&#125;\n\t\tA[j + 1] &#x3D; key;\t&#x2F;&#x2F;将key插入向右移空出的空位\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"算法描述-3\"><a class=\"markdownIt-Anchor\" href=\"#算法描述-3\"></a> 算法描述</h5>\n<h4 id=\"希尔排序\"><a class=\"markdownIt-Anchor\" href=\"#希尔排序\"></a> 希尔排序</h4>\n<h5 id=\"c实现-4\"><a class=\"markdownIt-Anchor\" href=\"#c实现-4\"></a> C++实现</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h5 id=\"算法描述-4\"><a class=\"markdownIt-Anchor\" href=\"#算法描述-4\"></a> 算法描述</h5>\n<h3 id=\"3选择排序\"><a class=\"markdownIt-Anchor\" href=\"#3选择排序\"></a> 3.选择排序</h3>\n<h4 id=\"选择排序\"><a class=\"markdownIt-Anchor\" href=\"#选择排序\"></a> 选择排序</h4>\n<h5 id=\"c实现-5\"><a class=\"markdownIt-Anchor\" href=\"#c实现-5\"></a> C++实现</h5>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void SelectionSort(int* A, int n)&#123;\t&#x2F;&#x2F;A:待排序数组指针, n:数组内元素个数\n\tfor(int i &#x3D; 0; i &lt; n; i ++)&#123;\n\t\tint min &#x3D; A[i], minindex &#x3D; i;\n\t\tfor(int j &#x3D; i + 1; j &lt; n; j ++)&#123;\t&#x2F;&#x2F;找出A[i+1...n-1]中最小值下标\n\t\t\tif(A[j] &lt; min)&#123;\n\t\t\t\tmin&#x3D; A[j];\n\t\t\t\tminindex &#x3D; j;\n\t\t\t&#125;\n\t\t&#125;\n\t\tint temp &#x3D; A[i];\t&#x2F;&#x2F;交换最小值与A[i]的值\n\t\tA[i] &#x3D; A[minindex];\n\t\tA[minindex] &#x3D; temp;\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"算法描述-5\"><a class=\"markdownIt-Anchor\" href=\"#算法描述-5\"></a> 算法描述</h5>\n<h4 id=\"堆排序\"><a class=\"markdownIt-Anchor\" href=\"#堆排序\"></a> 堆排序</h4>\n<h5 id=\"c实现-6\"><a class=\"markdownIt-Anchor\" href=\"#c实现-6\"></a> C++实现</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h5 id=\"算法描述-6\"><a class=\"markdownIt-Anchor\" href=\"#算法描述-6\"></a> 算法描述</h5>\n<h3 id=\"4归并排序\"><a class=\"markdownIt-Anchor\" href=\"#4归并排序\"></a> 4.归并排序</h3>\n<h4 id=\"二路归并排序\"><a class=\"markdownIt-Anchor\" href=\"#二路归并排序\"></a> 二路归并排序</h4>\n<h5 id=\"c实现-7\"><a class=\"markdownIt-Anchor\" href=\"#c实现-7\"></a> C++实现</h5>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#define INF 0x7FFFFFFF\n\nvoid Merge(int* A, int p, int q, int r)&#123;\t&#x2F;&#x2F;A:待归并数组指针,p:归并区段起始下标,q:归并区段中间点下标,r:归并区段末尾下标\n\tint n1 &#x3D; q - p + 1, n2 &#x3D; r - q, i &#x3D; 0, j &#x3D; 0;\n\tint* B &#x3D; new int[n1 + 1];\t&#x2F;&#x2F;制作两个堆\n\tint* C &#x3D; new int[n2 + 1];\n\tB[n1] &#x3D; INF;\t&#x2F;&#x2F;信号量\n\tC[n2] &#x3D; INF;\n\tfor(int i &#x3D; 0; i &lt; n1; i ++) B[i] &#x3D; A[p + i];\t&#x2F;&#x2F;拷贝元素\n\tfor(int i &#x3D; 0; i &lt; n2; i ++) C[i] &#x3D; A[q+i+1];\n\tfor(int k &#x3D; p; k &lt;&#x3D; r; k ++)&#123;\n\t\tif(B[i] &lt;&#x3D; C[j]) &#123;\n\t\t\tA[k] &#x3D; B[i];\n\t\t\ti ++;\n\t\t&#125; else&#123;\n\t\t\tA[k] &#x3D; C[j];\n\t\t\tj ++;\t\n\t\t&#125;\n\t&#125;\n\tdelete[] B;\n\tdelete[] C;\n&#125;\n\nvoid MergeSort(int* A, int p, int r)&#123;\t&#x2F;&#x2F;A:待排序数组指针,p:起始下标,r:结束下标\n\tif(p &lt; r)&#123;\t&#x2F;&#x2F;若p&gt;&#x3D;r时,A已有序,直接返回\n\t\tint q &#x3D; (p + r) &#x2F; 2;\t&#x2F;&#x2F;分解问题\n\t\tMergeSort(A, p, q);\t&#x2F;&#x2F;递归求解子问题\n\t\tMergeSort(A, q + 1, r);\n\t\tMerge(A, p, q, r);\t&#x2F;&#x2F;合并子问题解\n\t&#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"算法描述-7\"><a class=\"markdownIt-Anchor\" href=\"#算法描述-7\"></a> 算法描述</h5>\n<h4 id=\"多路归并排序\"><a class=\"markdownIt-Anchor\" href=\"#多路归并排序\"></a> 多路归并排序</h4>\n<h5 id=\"c实现-8\"><a class=\"markdownIt-Anchor\" href=\"#c实现-8\"></a> C++实现</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h5 id=\"算法描述-8\"><a class=\"markdownIt-Anchor\" href=\"#算法描述-8\"></a> 算法描述</h5>\n<h1 id=\"二非比较排序\"><a class=\"markdownIt-Anchor\" href=\"#二非比较排序\"></a> 二.非比较排序</h1>\n<h3 id=\"1计数排序\"><a class=\"markdownIt-Anchor\" href=\"#1计数排序\"></a> 1.计数排序</h3>\n<h5 id=\"c实现-9\"><a class=\"markdownIt-Anchor\" href=\"#c实现-9\"></a> C++实现</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h5 id=\"算法描述-9\"><a class=\"markdownIt-Anchor\" href=\"#算法描述-9\"></a> 算法描述</h5>\n<h3 id=\"2桶排序\"><a class=\"markdownIt-Anchor\" href=\"#2桶排序\"></a> 2.桶排序</h3>\n<h5 id=\"c实现-10\"><a class=\"markdownIt-Anchor\" href=\"#c实现-10\"></a> C++实现</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h5 id=\"算法描述-10\"><a class=\"markdownIt-Anchor\" href=\"#算法描述-10\"></a> 算法描述</h5>\n<h3 id=\"3基数排序\"><a class=\"markdownIt-Anchor\" href=\"#3基数排序\"></a> 3.基数排序</h3>\n<h5 id=\"c实现-11\"><a class=\"markdownIt-Anchor\" href=\"#c实现-11\"></a> C++实现</h5>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h5 id=\"算法描述-11\"><a class=\"markdownIt-Anchor\" href=\"#算法描述-11\"></a> 算法描述</h5>\n","feature":true,"text":" 常见排序算法实现及浅析 一.比较排序 1.交换排序 冒泡排序 C++实现 算法描述 快速排序 C++实现 int Partition(int* A, int p, int r)&#123; int q &#x3D; p; for(int u &#x3D; p; u &lt; r...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":1,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"Notes","slug":"Notes","count":4,"path":"api/tags/Notes.json"},{"name":"Sort","slug":"Sort","count":4,"path":"api/tags/Sort.json"},{"name":"排序算法","slug":"排序算法","count":3,"path":"api/tags/排序算法.json"},{"name":"C++","slug":"C","count":1,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%B5%85%E6%9E%90\"><span class=\"toc-text\"> 常见排序算法实现及浅析</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\"> 一.比较排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\"> 1.交换排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\"> 冒泡排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\"> C++实现</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\"> 算法描述</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\"> 快速排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c%E5%AE%9E%E7%8E%B0-2\"><span class=\"toc-text\"> C++实现</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-2\"><span class=\"toc-text\"> 算法描述</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\"> 2.插入排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\"> 插入排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c%E5%AE%9E%E7%8E%B0-3\"><span class=\"toc-text\"> C++实现</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-3\"><span class=\"toc-text\"> 算法描述</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\"> 希尔排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c%E5%AE%9E%E7%8E%B0-4\"><span class=\"toc-text\"> C++实现</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-4\"><span class=\"toc-text\"> 算法描述</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\"> 3.选择排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\"> 选择排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c%E5%AE%9E%E7%8E%B0-5\"><span class=\"toc-text\"> C++实现</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-5\"><span class=\"toc-text\"> 算法描述</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A0%86%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\"> 堆排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c%E5%AE%9E%E7%8E%B0-6\"><span class=\"toc-text\"> C++实现</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-6\"><span class=\"toc-text\"> 算法描述</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\"> 4.归并排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E8%B7%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\"> 二路归并排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c%E5%AE%9E%E7%8E%B0-7\"><span class=\"toc-text\"> C++实现</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-7\"><span class=\"toc-text\"> 算法描述</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\"> 多路归并排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c%E5%AE%9E%E7%8E%B0-8\"><span class=\"toc-text\"> C++实现</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-8\"><span class=\"toc-text\"> 算法描述</span></a></li></ol></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E9%9D%9E%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\"> 二.非比较排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\"> 1.计数排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c%E5%AE%9E%E7%8E%B0-9\"><span class=\"toc-text\"> C++实现</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-9\"><span class=\"toc-text\"> 算法描述</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%E6%A1%B6%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\"> 2.桶排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c%E5%AE%9E%E7%8E%B0-10\"><span class=\"toc-text\"> C++实现</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-10\"><span class=\"toc-text\"> 算法描述</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\"> 3.基数排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c%E5%AE%9E%E7%8E%B0-11\"><span class=\"toc-text\"> C++实现</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-11\"><span class=\"toc-text\"> 算法描述</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Minecraft1248","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2021/10/89a7ea01b14a6553.jpg","link":"/","description":"Helium项目开发人员lol","socials":{"github":"https://github.com/Minecraft1248","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/270016803"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"《算法基础》学习笔记-排序算法测试源代码","uid":"edd55adac64d0984201add6954665563","slug":"Algorithm-Unlocked-Sort-Test-Source-Code","date":"2021-10-30T16:13:46.000Z","updated":"2021-10-30T16:15:45.770Z","comments":true,"path":"api/articles/Algorithm-Unlocked-Sort-Test-Source-Code.json","keywords":"Minecraft1248","cover":"https://s3.bmp.ovh/imgs/2021/10/5bcb09e1b9a4aeb0.jpg","text":"#include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;ctime&gt; #include&lt;vector&gt; #define INF 0x7FFFFFFF using namespace std; in...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"算法基础","slug":"算法基础","count":3,"path":"api/categories/算法基础.json"},{"name":"Algorithms Unlocked","slug":"算法基础/Algorithms-Unlocked","count":3,"path":"api/categories/算法基础/Algorithms-Unlocked.json"},{"name":"学习笔记","slug":"算法基础/Algorithms-Unlocked/学习笔记","count":3,"path":"api/categories/算法基础/Algorithms-Unlocked/学习笔记.json"}],"tags":[{"name":"Notes","slug":"Notes","count":4,"path":"api/tags/Notes.json"},{"name":"Sort","slug":"Sort","count":4,"path":"api/tags/Sort.json"},{"name":"排序算法","slug":"排序算法","count":3,"path":"api/tags/排序算法.json"}],"author":{"name":"Minecraft1248","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2021/10/89a7ea01b14a6553.jpg","link":"/","description":"Helium项目开发人员lol","socials":{"github":"https://github.com/Minecraft1248","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/270016803"}}}},"feature":true}}