{"title":"C++STL-vector容器使用详解","uid":"106355e839593b02e07102f13b5621b5","slug":"C++STLvector容器使用详解","date":"2021-11-06T07:06:45.000Z","updated":"2021-11-06T09:17:48.021Z","comments":true,"path":"api/articles/C++STLvector容器使用详解.json","keywords":"Minecraft1248","cover":null,"content":"<h1 id=\"cstl-vector容器使用详解\"><a class=\"markdownIt-Anchor\" href=\"#cstl-vector容器使用详解\"></a> C++STL-vector容器使用详解</h1>\n<h2 id=\"0简单介绍\"><a class=\"markdownIt-Anchor\" href=\"#0简单介绍\"></a> 0.简单介绍</h2>\n<p>​\tvector又称向量容器,是STL提供的容器之一,可以通过模板参数的指定来进行不同种类元素的储存,其储存在内存中是连续的,故vector访问元素的速度为O(1),而删除,插入vector均为O(n),vector也可以理解为一个动态数组.</p>\n<p>​\tvector会对传递的储存类型进行<code>std::is_copy_constructible&lt;&gt;</code>检查,故<strong>vector中的储存类型一定是可拷贝构造的</strong>(如<code>std::thread</code>不是).</p>\n<p>​\t在使用vector前<strong>应添加相应<code>#include&lt;vector&gt;</code></strong>.</p>\n<h2 id=\"1构造函数\"><a class=\"markdownIt-Anchor\" href=\"#1构造函数\"></a> 1.构造函数</h2>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; vec1;\t&#x2F;&#x2F;默认构造函数\nvector&lt;int&gt; vec2(10);\t&#x2F;&#x2F;创建一个具有10个int类型元素的vector\nvector&lt;int&gt; vec3(20, 5)\t&#x2F;&#x2F;创建一个具有20个int类型元素的vector,且每个元素初值为5\nvector&lt;int&gt; vec4(vec3)\t&#x2F;&#x2F;以vec3给vec4赋值,此时两者完全相同\nvector&lt;int&gt; vec4(vec3.begin() + 2, vec3.begin() + 5) &#x2F;&#x2F;将vec3[1...4](注意下标)的值赋值给vec4\nint a[10] &#x3D; &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;\nvector&lt;int&gt; vec5(b + 1,  b + 7);\t&#x2F;&#x2F;将b[1...7]赋值给vec5<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"2成员函数\"><a class=\"markdownIt-Anchor\" href=\"#2成员函数\"></a> 2.成员函数</h2>\n<p>​\t<em>如果不了解迭代器可以去看我的那篇《C++STL-迭代器的使用》</em></p>\n<h3 id=\"迭代器相关\"><a class=\"markdownIt-Anchor\" href=\"#迭代器相关\"></a> 迭代器相关</h3>\n<h4 id=\"1begin\"><a class=\"markdownIt-Anchor\" href=\"#1begin\"></a> 1.begin()</h4>\n<p>​\t返回指向容器中<strong>第一个元素的正向迭代器</strong>.</p>\n<h4 id=\"2end\"><a class=\"markdownIt-Anchor\" href=\"#2end\"></a> 2.end()</h4>\n<p>​\t返回指向容器中<strong>最后元素的正向迭代器</strong>.</p>\n<h4 id=\"3rbegin\"><a class=\"markdownIt-Anchor\" href=\"#3rbegin\"></a> 3.rbegin()</h4>\n<p>​\t返回指向容器中<strong>第一个元素的反向迭代器</strong>.</p>\n<h4 id=\"4rend\"><a class=\"markdownIt-Anchor\" href=\"#4rend\"></a> 4.rend()</h4>\n<p>​\t返回指向容器中<strong>最后元素的反向迭代器</strong>.</p>\n<h4 id=\"5cbegin\"><a class=\"markdownIt-Anchor\" href=\"#5cbegin\"></a> 5.cbegin()</h4>\n<p>​\t返回指向容器中<strong>第一个元素的常量正向迭代器</strong>.</p>\n<h4 id=\"6cend\"><a class=\"markdownIt-Anchor\" href=\"#6cend\"></a> 6.cend()</h4>\n<p>​\t返回指向容器中<strong>最后元素的常量正向迭代器</strong>.</p>\n<h4 id=\"7crbegin\"><a class=\"markdownIt-Anchor\" href=\"#7crbegin\"></a> 7.crbegin()</h4>\n<p>​\t返回指向容器中<strong>第一个元素的常量反向迭代器</strong>.</p>\n<h4 id=\"8crend\"><a class=\"markdownIt-Anchor\" href=\"#8crend\"></a> 8.crend()</h4>\n<p>​\t返回指向容器中<strong>最后元素的常量反向迭代器</strong>.</p>\n<h3 id=\"vector储存相关\"><a class=\"markdownIt-Anchor\" href=\"#vector储存相关\"></a> vector储存相关</h3>\n<h4 id=\"1size\"><a class=\"markdownIt-Anchor\" href=\"#1size\"></a> 1.size()</h4>\n<h4 id=\"2capacity\"><a class=\"markdownIt-Anchor\" href=\"#2capacity\"></a> 2.capacity()</h4>\n<h4 id=\"3resize\"><a class=\"markdownIt-Anchor\" href=\"#3resize\"></a> 3.resize()</h4>\n<h4 id=\"4empty\"><a class=\"markdownIt-Anchor\" href=\"#4empty\"></a> 4.empty()</h4>\n<h4 id=\"5reserve\"><a class=\"markdownIt-Anchor\" href=\"#5reserve\"></a> 5.reserve()</h4>\n<h3 id=\"元素访问相关\"><a class=\"markdownIt-Anchor\" href=\"#元素访问相关\"></a> 元素访问相关</h3>\n<h4 id=\"1运算符重载operator\"><a class=\"markdownIt-Anchor\" href=\"#1运算符重载operator\"></a> 1.(运算符重载)operator[]</h4>\n<h4 id=\"2at\"><a class=\"markdownIt-Anchor\" href=\"#2at\"></a> <a href=\"http://2.at\">2.at</a>()</h4>\n<h4 id=\"3front\"><a class=\"markdownIt-Anchor\" href=\"#3front\"></a> 3.front()</h4>\n<h4 id=\"4back\"><a class=\"markdownIt-Anchor\" href=\"#4back\"></a> 4.back()</h4>\n<h3 id=\"内容修改相关\"><a class=\"markdownIt-Anchor\" href=\"#内容修改相关\"></a> 内容修改相关</h3>\n<h4 id=\"1assign\"><a class=\"markdownIt-Anchor\" href=\"#1assign\"></a> 1.assign()</h4>\n<h4 id=\"2push_back\"><a class=\"markdownIt-Anchor\" href=\"#2push_back\"></a> 2.push_back()</h4>\n<h4 id=\"3pop_back\"><a class=\"markdownIt-Anchor\" href=\"#3pop_back\"></a> 3.pop_back()</h4>\n<h4 id=\"4insert\"><a class=\"markdownIt-Anchor\" href=\"#4insert\"></a> 4.insert()</h4>\n<h4 id=\"5erase\"><a class=\"markdownIt-Anchor\" href=\"#5erase\"></a> 5.erase()</h4>\n<h4 id=\"6swap\"><a class=\"markdownIt-Anchor\" href=\"#6swap\"></a> 6.swap()</h4>\n<h4 id=\"7clear\"><a class=\"markdownIt-Anchor\" href=\"#7clear\"></a> 7.clear()</h4>\n<h4 id=\"8emplace\"><a class=\"markdownIt-Anchor\" href=\"#8emplace\"></a> 8.emplace()</h4>\n<h4 id=\"9emplace_back\"><a class=\"markdownIt-Anchor\" href=\"#9emplace_back\"></a> 9.emplace_back()</h4>\n","text":" C++STL-vector容器使用详解 0.简单介绍 ​ vector又称向量容器,是STL提供的容器之一,可以通过模板参数的指定来进行不同种类元素的储存,其储存在内存中是连续的,故vector访问元素的速度为O(1),而删除,插入vector均为O(n),vector也可以理...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"C++STL","slug":"C-STL","count":2,"path":"api/categories/C-STL.json"}],"tags":[{"name":"Notes","slug":"Notes","count":8,"path":"api/tags/Notes.json"},{"name":"STL","slug":"STL","count":2,"path":"api/tags/STL.json"},{"name":"vector","slug":"vector","count":1,"path":"api/tags/vector.json"},{"name":"C++","slug":"C","count":4,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#cstl-vector%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\"> C++STL-vector容器使用详解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\"> 0.简单介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\"> 1.构造函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\"> 2.成员函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\"> 迭代器相关</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1begin\"><span class=\"toc-text\"> 1.begin()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2end\"><span class=\"toc-text\"> 2.end()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3rbegin\"><span class=\"toc-text\"> 3.rbegin()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4rend\"><span class=\"toc-text\"> 4.rend()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5cbegin\"><span class=\"toc-text\"> 5.cbegin()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6cend\"><span class=\"toc-text\"> 6.cend()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7crbegin\"><span class=\"toc-text\"> 7.crbegin()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8crend\"><span class=\"toc-text\"> 8.crend()</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#vector%E5%82%A8%E5%AD%98%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\"> vector储存相关</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1size\"><span class=\"toc-text\"> 1.size()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2capacity\"><span class=\"toc-text\"> 2.capacity()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3resize\"><span class=\"toc-text\"> 3.resize()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4empty\"><span class=\"toc-text\"> 4.empty()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5reserve\"><span class=\"toc-text\"> 5.reserve()</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\"> 元素访问相关</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BDoperator\"><span class=\"toc-text\"> 1.(运算符重载)operator[]</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2at\"><span class=\"toc-text\"> 2.at()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3front\"><span class=\"toc-text\"> 3.front()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4back\"><span class=\"toc-text\"> 4.back()</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AE%B9%E4%BF%AE%E6%94%B9%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\"> 内容修改相关</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1assign\"><span class=\"toc-text\"> 1.assign()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2push_back\"><span class=\"toc-text\"> 2.push_back()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3pop_back\"><span class=\"toc-text\"> 3.pop_back()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4insert\"><span class=\"toc-text\"> 4.insert()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5erase\"><span class=\"toc-text\"> 5.erase()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6swap\"><span class=\"toc-text\"> 6.swap()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7clear\"><span class=\"toc-text\"> 7.clear()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8emplace\"><span class=\"toc-text\"> 8.emplace()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9emplace_back\"><span class=\"toc-text\"> 9.emplace_back()</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Minecraft1248","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2021/10/89a7ea01b14a6553.jpg","link":"/","description":"Helium项目开发人员lol","socials":{"github":"https://github.com/Minecraft1248","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/270016803"}}}},"mapped":true,"prev_post":{"title":"Helium项目简介","uid":"c556e014e1cd2aeced9fbf030f4918f6","slug":"helium-project-introduction-2021-10-9","date":"2021-10-09T15:51:59.000Z","updated":"2021-10-09T17:16:58.749Z","comments":true,"path":"api/articles/helium-project-introduction-2021-10-9.json","keywords":"Minecraft1248","cover":"https://s3.bmp.ovh/imgs/2021/10/c6091162b41668f1.png","text":" Helium项目简介 一.什么是Helium ​ Helium是一个由Fallen-Breath/MCDReforged项目所启发的,由C++编写的Minecraft服务端控制工具.与MCDR类似的是,Helium同样不需要对Minecraft服务端进行修改即可提供一个可自定义...","link":"","photos":[],"count_time":{"symbolsCount":816,"symbolsTime":"1 mins."},"categories":[{"name":"Helium","slug":"Helium","count":2,"path":"api/categories/Helium.json"}],"tags":[{"name":"Helium","slug":"Helium","count":2,"path":"api/tags/Helium.json"},{"name":"Github","slug":"Github","count":2,"path":"api/tags/Github.json"}],"author":{"name":"Minecraft1248","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2021/10/89a7ea01b14a6553.jpg","link":"/","description":"Helium项目开发人员lol","socials":{"github":"https://github.com/Minecraft1248","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/270016803"}}}},"feature":true},"next_post":{"title":"《离散数学》学习笔记-命题逻辑","uid":"ac0376559f56322e9106da1c6d59f0ba","slug":"《离散数学》学习笔记","date":"2021-11-05T14:44:24.000Z","updated":"2021-11-05T14:48:22.877Z","comments":true,"path":"api/articles/《离散数学》学习笔记.json","keywords":"Minecraft1248","cover":"https://s3.bmp.ovh/imgs/2021/11/b43b44e84cda2675.webp","text":" 《离散数学》学习笔记 第一篇 命题逻辑 1-1 命题及其表示法 ​ 目标语言和公式符号形成了数理逻辑的形式符号体系,目标语言就是表达判断的一些语言的汇集,而判断就是对事物有肯定或否定的一种思维形式,因此,能表达判断的语言是陈述句,称作一个命题. ​ 一个命题总是具有一个值,称为...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"离散数学","slug":"离散数学","count":1,"path":"api/categories/离散数学.json"},{"name":"Discrete Mathematics","slug":"离散数学/Discrete-Mathematics","count":1,"path":"api/categories/离散数学/Discrete-Mathematics.json"},{"name":"学习笔记","slug":"离散数学/Discrete-Mathematics/学习笔记","count":1,"path":"api/categories/离散数学/Discrete-Mathematics/学习笔记.json"}],"tags":[{"name":"Notes","slug":"Notes","count":8,"path":"api/tags/Notes.json"},{"name":"Discrete Mathematics","slug":"Discrete-Mathematics","count":1,"path":"api/tags/Discrete-Mathematics.json"},{"name":"离散数学","slug":"离散数学","count":1,"path":"api/tags/离散数学.json"},{"name":"命题逻辑","slug":"命题逻辑","count":1,"path":"api/tags/命题逻辑.json"}],"author":{"name":"Minecraft1248","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2021/10/89a7ea01b14a6553.jpg","link":"/","description":"Helium项目开发人员lol","socials":{"github":"https://github.com/Minecraft1248","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/270016803"}}}}}}