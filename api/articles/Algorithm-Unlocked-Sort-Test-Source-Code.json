{"title":"《算法基础》学习笔记-排序算法测试源代码","uid":"edd55adac64d0984201add6954665563","slug":"Algorithm-Unlocked-Sort-Test-Source-Code","date":"2021-10-30T16:13:46.000Z","updated":"2021-10-30T16:15:45.770Z","comments":true,"path":"api/articles/Algorithm-Unlocked-Sort-Test-Source-Code.json","keywords":"Minecraft1248","cover":"https://s3.bmp.ovh/imgs/2021/10/5bcb09e1b9a4aeb0.jpg","content":"<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;iostream&gt;\n#include&lt;cstdlib&gt;\n#include&lt;ctime&gt;\n#include&lt;vector&gt;\n\n#define INF 0x7FFFFFFF\n\nusing namespace std;\n\nint RandomPartition(int* A, int p, int r) &#123;\n\tint a &#x3D; (rand() % (r - p)) + p;\n\tint temp &#x3D; A[r];\n\tA[r] &#x3D; A[a];\n\tA[a] &#x3D; temp;\n\tint q &#x3D; p;\n\tfor (int u &#x3D; p; u &lt; r; u++) &#123;\n\t\tif (A[u] &lt;&#x3D; A[r]) &#123;\n\t\t\tint temp &#x3D; A[u];\n\t\t\tA[u] &#x3D; A[q];\n\t\t\tA[q] &#x3D; temp;\n\t\t\tq++;\n\t\t&#125;\n\t&#125;\n\ttemp &#x3D; A[r];\n\tA[r] &#x3D; A[q];\n\tA[q] &#x3D; temp;\n\treturn q;\n&#125;\n\nvoid RandomQuickSort(int* A, int p, int r) &#123;\n\tif (p &lt; r) &#123;\n\t\tint q &#x3D; RandomPartition(A, p, r);\n\t\tRandomQuickSort(A, p, q - 1);\n\t\tRandomQuickSort(A, q + 1, r);\n\t&#125;\n&#125;\n\nvoid SelectionSort(int* A, int n) &#123;\n\tfor (int i &#x3D; 0; i &lt; n; i++) &#123;\n\t\tint min &#x3D; A[i], minindex &#x3D; i;\n\t\tfor (int j &#x3D; i + 1; j &lt; n; j++) &#123;\n\t\t\tif (A[j] &lt; min) &#123;\n\t\t\t\tmin &#x3D; A[j];\n\t\t\t\tminindex &#x3D; j;\n\t\t\t&#125;\n\t\t&#125;\n\t\tint temp &#x3D; A[i];\n\t\tA[i] &#x3D; A[minindex];\n\t\tA[minindex] &#x3D; temp;\n\t&#125;\n&#125;\n\nvoid InsertionSort(int* A, int n) &#123;\n\tfor (int i &#x3D; 1; i &lt; n; i++) &#123;\n\t\tint key &#x3D; A[i], j &#x3D; i - 1;\n\t\twhile (j &gt;&#x3D; 0 &amp;&amp; A[j] &gt; key) &#123;\n\t\t\tA[j + 1] &#x3D; A[j];\n\t\t\tj--;\n\t\t&#125;\n\t\tA[j + 1] &#x3D; key;\n\t&#125;\n&#125;\n\nvoid Merge(int* A, int p, int q, int r) &#123;\n\tint n1 &#x3D; q - p + 1, n2 &#x3D; r - q, i &#x3D; 0, j &#x3D; 0;\n\tint* B &#x3D; new int[n1 + 1];\n\tint* C &#x3D; new int[n2 + 1];\n\tB[n1] &#x3D; INF;\n\tC[n2] &#x3D; INF;\n\tfor (int i &#x3D; 0; i &lt; n1; i++) B[i] &#x3D; A[p + i];\n\tfor (int i &#x3D; 0; i &lt; n2; i++) C[i] &#x3D; A[q + i + 1];\n\tfor (int k &#x3D; p; k &lt;&#x3D; r; k++) &#123;\n\t\tif (B[i] &lt;&#x3D; C[j]) &#123;\n\t\t\tA[k] &#x3D; B[i];\n\t\t\ti++;\n\t\t&#125;\n\t\telse &#123;\n\t\t\tA[k] &#x3D; C[j];\n\t\t\tj++;\n\t\t&#125;\n\t&#125;\n\tdelete[] B;\n\tdelete[] C;\n&#125;\n\nvoid MergeSort(int* A, int p, int r) &#123;\n\tif (p &lt; r) &#123;\n\t\tint q &#x3D; (p + r) &#x2F; 2;\n\t\tMergeSort(A, p, q);\n\t\tMergeSort(A, q + 1, r);\n\t\tMerge(A, p, q, r);\n\t&#125;\n&#125;\n\nint Partition(int* A, int p, int r) &#123;\n\tint q &#x3D; p;\n\tfor (int u &#x3D; p; u &lt; r; u++) &#123;\n\t\tif (A[u] &lt;&#x3D; A[r]) &#123;\n\t\t\tint temp &#x3D; A[u];\n\t\t\tA[u] &#x3D; A[q];\n\t\t\tA[q] &#x3D; temp;\n\t\t\tq++;\n\t\t&#125;\n\t&#125;\n\tint temp &#x3D; A[r];\n\tA[r] &#x3D; A[q];\n\tA[q] &#x3D; temp;\n\treturn q;\n&#125;\n\nvoid QuickSort(int* A, int p, int r) &#123;\n\tif (p &lt; r) &#123;\n\t\tint q &#x3D; Partition(A, p, r);\n\t\tQuickSort(A, p, q - 1);\n\t\tQuickSort(A, q + 1, r);\n\t&#125;\n&#125;\n\nint main(int argc, char** argv) &#123;\n\tint n &#x3D; 0, lt &#x3D; 0;\n\tclock_t start, end;\n\tdouble temptime &#x3D; 0.0, sum &#x3D; 0.0;\n\tdouble sorttime[5] &#x3D; &#123; 0.0 &#125;;\n\tvector&lt;double&gt; tempsorttime;\n\n\tcout &lt;&lt; &quot;Enter the Input data scale : &quot;;\n\tcin &gt;&gt; n;\n\tcout &lt;&lt; &quot;Enter the Loop time : &quot;;\n\tcin &gt;&gt; lt;\n\n\tint* A &#x3D; new int[n];\n\n\ttempsorttime.clear();\n\tfor (int i &#x3D; 0; i &lt; lt; i++) &#123;\n\t\tsrand((int)time(NULL));\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\tA[i] &#x3D; rand();\n\n\t\tstart &#x3D; clock();\n\t\tInsertionSort(A, n);\n\t\tend &#x3D; clock();\n\t\ttemptime &#x3D; (double)(end - start);\n\t\ttempsorttime.push_back(temptime);\n\t\tcout &lt;&lt; &quot;Insertion Sort time : &quot; &lt;&lt; temptime &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\t&#125;\n\tsum &#x3D; 0.0;\n\tfor (auto i : tempsorttime) &#123;\n\t\tsum +&#x3D; i;\n\t&#125;\n\tsorttime[0] &#x3D; (double)sum &#x2F; lt;\n\n\ttempsorttime.clear();\n\tfor (int i &#x3D; 0; i &lt; lt; i++) &#123;\n\t\tsrand((int)time(NULL));\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\tA[i] &#x3D; rand();\n\n\t\tstart &#x3D; clock();\n\t\tSelectionSort(A, n);\n\t\tend &#x3D; clock();\n\t\ttemptime &#x3D; (double)(end - start);\n\t\ttempsorttime.push_back(temptime);\n\t\tcout &lt;&lt; &quot;Selection Sort time : &quot; &lt;&lt; temptime &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\t&#125;\n\tsum &#x3D; 0.0;\n\tfor (auto i : tempsorttime) &#123;\n\t\tsum +&#x3D; i;\n\t&#125;\n\tsorttime[1] &#x3D; (double)sum &#x2F; lt;\n\n\ttempsorttime.clear();\n\tfor (int i &#x3D; 0; i &lt; lt; i++) &#123;\n\t\tsrand((int)time(NULL));\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\tA[i] &#x3D; rand();\n\n\t\tstart &#x3D; clock();\n\t\tMergeSort(A, 0, n - 1);\n\t\tend &#x3D; clock();\n\t\ttemptime &#x3D; (double)(end - start);\n\t\ttempsorttime.push_back(temptime);\n\t\tcout &lt;&lt; &quot;Merge Sort time : &quot; &lt;&lt; temptime &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\t&#125;\n\tsum &#x3D; 0.0;\n\tfor (auto i : tempsorttime) &#123;\n\t\tsum +&#x3D; i;\n\t&#125;\n\tsorttime[2] &#x3D; (double)sum &#x2F; lt;\n\n\ttempsorttime.clear();\n\tfor (int i &#x3D; 0; i &lt; lt; i++) &#123;\n\t\tsrand((int)time(NULL));\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\tA[i] &#x3D; rand();\n\n\t\tstart &#x3D; clock();\n\t\tQuickSort(A, 0, n - 1);\n\t\tend &#x3D; clock();\n\t\ttemptime &#x3D; (double)(end - start);\n\t\ttempsorttime.push_back(temptime);\n\t\tcout &lt;&lt; &quot;Quick Sort time : &quot; &lt;&lt; temptime &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\t&#125;\n\tsum &#x3D; 0.0;\n\tfor (auto i : tempsorttime) &#123;\n\t\tsum +&#x3D; i;\n\t&#125;\n\tsorttime[3] &#x3D; (double)sum &#x2F; lt;\n\n\ttempsorttime.clear();\n\tfor (int i &#x3D; 0; i &lt; lt; i++) &#123;\n\t\tsrand((int)time(NULL));\n\t\tfor (int i &#x3D; 0; i &lt; n; i++)\tA[i] &#x3D; rand();\n\n\t\tstart &#x3D; clock();\n\t\tRandomQuickSort(A, 0, n - 1);\n\t\tend &#x3D; clock();\n\t\ttemptime &#x3D; (double)(end - start);\n\t\ttempsorttime.push_back(temptime);\n\t\tcout &lt;&lt; &quot;Randomized Quick Sort time : &quot; &lt;&lt; temptime &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\t&#125;\n\tsum &#x3D; 0.0;\n\tfor (auto i : tempsorttime) &#123;\n\t\tsum +&#x3D; i;\n\t&#125;\n\tsorttime[4] &#x3D; (double)sum &#x2F; lt;\n\n\tcout &lt;&lt; endl &lt;&lt; &quot;Final time:&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Insertion Sort : &quot; &lt;&lt; sorttime[0] &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Selection Sort : &quot; &lt;&lt; sorttime[1] &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Merge Sort : &quot; &lt;&lt; sorttime[2] &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Quick Sort : &quot; &lt;&lt; sorttime[3] &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Randomized Quick Sort : &quot; &lt;&lt; sorttime[4] &lt;&lt; &quot;ms&quot; &lt;&lt; endl;\n\n\tdelete[] A;\n\tA &#x3D; NULL;\n\tsystem(&quot;pause&quot;);\n\treturn 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","feature":true,"text":"#include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;ctime&gt; #include&lt;vector&gt; #define INF 0x7FFFFFFF using namespace std; in...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"算法基础","slug":"算法基础","count":3,"path":"api/categories/算法基础.json"},{"name":"Algorithms Unlocked","slug":"算法基础/Algorithms-Unlocked","count":3,"path":"api/categories/算法基础/Algorithms-Unlocked.json"},{"name":"学习笔记","slug":"算法基础/Algorithms-Unlocked/学习笔记","count":3,"path":"api/categories/算法基础/Algorithms-Unlocked/学习笔记.json"}],"tags":[{"name":"Notes","slug":"Notes","count":4,"path":"api/tags/Notes.json"},{"name":"Sort","slug":"Sort","count":4,"path":"api/tags/Sort.json"},{"name":"排序算法","slug":"排序算法","count":3,"path":"api/tags/排序算法.json"}],"toc":"","author":{"name":"Minecraft1248","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2021/10/89a7ea01b14a6553.jpg","link":"/","description":"Helium项目开发人员lol","socials":{"github":"https://github.com/Minecraft1248","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/270016803"}}}},"mapped":true,"prev_post":{"title":"杂记-常见排序算法实现及其浅析","uid":"7b96841ab300f1a32883b72d5fd4ae72","slug":"常见排序算法实现及浅析","date":"2021-11-06T10:16:59.000Z","updated":"2021-11-06T02:57:14.894Z","comments":true,"path":"api/articles/常见排序算法实现及浅析.json","keywords":"Minecraft1248","cover":null,"text":" 常见排序算法实现及浅析 一.比较排序 1.交换排序 冒泡排序 C++实现 算法描述 快速排序 C++实现 int Partition(int* A, int p, int r)&#123; int q &#x3D; p; for(int u &#x3D; p; u &lt; r...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":1,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"Notes","slug":"Notes","count":4,"path":"api/tags/Notes.json"},{"name":"Sort","slug":"Sort","count":4,"path":"api/tags/Sort.json"},{"name":"排序算法","slug":"排序算法","count":3,"path":"api/tags/排序算法.json"},{"name":"C++","slug":"C","count":1,"path":"api/tags/C.json"}],"author":{"name":"Minecraft1248","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2021/10/89a7ea01b14a6553.jpg","link":"/","description":"Helium项目开发人员lol","socials":{"github":"https://github.com/Minecraft1248","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/270016803"}}}},"feature":true},"next_post":{"title":"Helium项目简介","uid":"c556e014e1cd2aeced9fbf030f4918f6","slug":"helium-project-introduction-2021-10-9","date":"2021-10-09T15:51:59.000Z","updated":"2021-10-09T17:16:58.749Z","comments":true,"path":"api/articles/helium-project-introduction-2021-10-9.json","keywords":"Minecraft1248","cover":"https://s3.bmp.ovh/imgs/2021/10/c6091162b41668f1.png","text":" Helium项目简介 一.什么是Helium ​ Helium是一个由Fallen-Breath/MCDReforged项目所启发的,由C++编写的Minecraft服务端控制工具.与MCDR类似的是,Helium同样不需要对Minecraft服务端进行修改即可提供一个可自定义...","link":"","photos":[],"count_time":{"symbolsCount":816,"symbolsTime":"1 mins."},"categories":[{"name":"Helium","slug":"Helium","count":2,"path":"api/categories/Helium.json"}],"tags":[{"name":"Helium","slug":"Helium","count":2,"path":"api/tags/Helium.json"},{"name":"Github","slug":"Github","count":2,"path":"api/tags/Github.json"}],"author":{"name":"Minecraft1248","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2021/10/89a7ea01b14a6553.jpg","link":"/","description":"Helium项目开发人员lol","socials":{"github":"https://github.com/Minecraft1248","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/270016803"}}}},"feature":true}}